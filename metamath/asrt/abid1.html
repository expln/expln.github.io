<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div id="react-container"></div>
<script>
const version = 'v8'
const relPathToRoot = '..'
const viewComponent = 'MetamathAssertionView'
const decompressionFunction = 'decompressAssertionDto'
const viewProps = JSON.parse("{\"s\":\"x A ph e. class |- wff setvar B } | { = <-> ) ( P F wcel vx cv cA biid abbi2i\",\"t\":\"Theorem\",\"n\":\"abid1\",\"d\":\"Every class is equal to a class abstraction (the class of sets belonging\\n       to it).  Theorem 5.2 of [Quine] p. 35.  This is a generalization to\\n       classes of ~ cvjust .  The proof does not rely on ~ cvjust , so ~ cvjust\\n       could be proved as a special instance of it.  Note however that ~ abid1\\n       necessarily relies on ~ df-clel , whereas ~ cvjust does not.\\n\\n       This theorem requires ~ ax-ext , ~ df-clab , ~ df-cleq , ~ df-clel , but\\n       to prove that any specific class term not containing class variables is\\n       a setvar or can be written as (is equal to) a class abstraction does not\\n       require these $a-statements.  This last fact is a metatheorem,\\n       consequence of the fact that the only $a-statements with typecode\\n       ` class ` are ~ cv , ~ cab and statements corresponding to defined class\\n       constructors.\\n\\n       Note on the simultaneous presence in set.mm of this ~ abid1 and its\\n       commuted form ~ abid2 :  It is rare that two forms so closely related\\n       both appear in set.mm.  Indeed, such equalities are generally used in\\n       later proofs as parts of transitive inferences, and with the many\\n       variants of ~ eqtri (search for *eqtr*), it would be rare that either\\n       one would shorten a proof compared to the other.  There is typically a\\n       choice between (what we call) a \\\"definitional form\\\" where the shorter\\n       expression is on the lhs, and a \\\"computational form\\\" where the shorter\\n       expression is on the rhs.  An example is ~ df-2 versus ~ 1p1e2 .  We do\\n       not need ~ 1p1e2 , but because it occurs \\\"naturally\\\" in computations, it\\n       can be useful to have it directly, together with a uniform set of\\n       1-digit operations like ~ 1p2e3 , etc.  In most cases, we do not need\\n       both a definitional and a computational forms.  A definitional form\\n       would favor consistency with genuine definitions, while a computationa\\n       form is often more natural.  The situation is similar with\\n       biconditionals in propositional calculus: see for instance ~ pm4.24 and\\n       ~ anidm , while other biconditionals generally appear in a single form\\n       (either definitional, but more often computational).  In the present\\n       case, the equality is important enough that both ~ abid1 and ~ abid2 are\\n       in set.mm.\\n\\n       (Contributed by NM, 26-Dec-1993.)  (Revised by BJ, 10-Nov-2020.)\",\"v\":\"#*$'%)+'\",\"pa\":\"\",\"r\":\"($/.#-#&$,\",\"p\":[\"1¦¦17¦19¦¦0¦¦¦*#\",\"2¦$¦1¦20¦*#¦1¦'#¦# #¦'#\",\"3¦¦17¦21¦¦0¦¦¦'$\",\"4¦%&¦1¦18¦'$ '+¦2¦)$&+¦$ # + $¦)#&$\",\"7¦'¦16¦22¦)%¦1¦(2%0%1¦% #&$¦(2#&$0#&$1\",\"8¦'$&*¦16¦23¦)% *# '$ (2#&$0%1¦3¦($/.#-%,¦# # $ $ % #&$¦($/.#-#&$,\"]}")
</script>
<script src="../v8/js/utils/all-imports.js"></script>
</body>
</html>
