<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div id="react-container"></div>
<script>
const version = 'v8'
const relPathToRoot = '..'
const viewComponent = 'MetamathAssertionView'
const decompressionFunction = 'decompressAssertionDto'
const viewProps = JSON.parse("{\"s\":\") ( , x n e. N U y setvar >. = <. if class ` _om _V /\\\\ (/) } |-> |- | { rec ^^ X. U. 1st 1o\",\"t\":\"Axiom\",\"n\":\"df-finxp\",\"d\":\"Define Cartesian exponentiation on a class.\\n\\n       Note that this definition is limited to finite exponents, since it is\\n       defined using nested ordered pairs.  If tuples of infinite length are\\n       needed, or if they might be needed in the future, use ~ df-ixp or\\n       ~ df-map instead.  The main advantage of this definition is that it\\n       integrates better with functions and relations.  For example if ` R ` is\\n       a subset of ` ( A ^^ 2o ) ` , then ~ df-br can be used on it, and\\n       ~ df-fv can also be used, and so on.\\n\\n       It's also worth keeping in mind that ` ( ( U ^^ M ) X. ( U ^^ N ) ) ` is\\n       generally not equal to ` ( U ^^ ( M +o N ) ) ` .\\n\\n       This definition is technical.  Use ~ finxp1o and ~ finxpsuc for a more\\n       standard recursive experience.  (Contributed by ML, 16-Oct-2020.)\",\"v\":\"&,',)1*1+,\",\"pa\":\"\",\"r\":\"9$*=)#.;+:$)(356.$<$$'(3%&(480$$'.A5&(*#%6%0$&($4>*#%/?'%$@2&#-%/'%&-###%/)%+-#2)##7\"}")
</script>
<script src="../v8/js/utils/all-imports.js"></script>
</body>
</html>
