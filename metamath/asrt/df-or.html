<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div id="react-container"></div>
<script>
const version = 'v8'
const relPathToRoot = '..'
const viewComponent = 'MetamathAssertionView'
const decompressionFunction = 'decompressAssertionDto'
const viewProps = JSON.parse("{\"s\":\"ps ph ) ( wff |- \\\\/ <-> -> -.\",\"t\":\"Axiom\",\"n\":\"df-or\",\"d\":\"Define disjunction (logical 'or').  Definition of [Margaris] p. 49.  When\\n     the left operand, right operand, or both are true, the result is true;\\n     when both sides are false, the result is false.  For example, it is true\\n     that ` ( 2 = 3 \\\\/ 4 = 4 ) ` ( ~ ex-or ).  After we define the constant\\n     true ` T. ` ( ~ df-tru ) and the constant false ` F. ` ( ~ df-fal ), we\\n     will be able to prove these truth table values:\\n     ` ( ( T. \\\\/ T. ) <-> T. ) ` ( ~ truortru ), ` ( ( T. \\\\/ F. ) <-> T. ) `\\n     ( ~ truorfal ), ` ( ( F. \\\\/ T. ) <-> T. ) ` ( ~ falortru ), and\\n     ` ( ( F. \\\\/ F. ) <-> F. ) ` ( ~ falorfal ).\\n\\n     This is our first use of the biconditional connective in a definition; we\\n     use the biconditional connective in place of the traditional \\\"<=def=>\\\",\\n     which means the same thing, except that we can manipulate the\\n     biconditional connective directly in proofs rather than having to rely on\\n     an informal definition substitution rule.  Note that if we mechanically\\n     substitute ` ( -. ph -> ps ) ` for ` ( ph \\\\/ ps ) ` , we end up with an\\n     instance of previously proved theorem ~ biid .  This is the justification\\n     for the definition, along with the fact that it introduces a new symbol\\n     ` \\\\/ ` .  Contrast with ` /\\\\ ` ( ~ df-an ), ` -> ` ( ~ wi ), ` -/\\\\ `\\n     ( ~ df-nan ), and ` \\\\/_ ` ( ~ df-xor ) .  (Contributed by NM,\\n     27-Dec-1992.)\",\"v\":\"#'$'\",\"pa\":\"\",\"r\":\"(&&$)#%*&,$+#%%\"}")
</script>
<script src="../v8/js/utils/all-imports.js"></script>
</body>
</html>
