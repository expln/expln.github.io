<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div id="react-container"></div>
<script>
const version = 'v8'
const relPathToRoot = '..'
const viewComponent = 'MetamathAssertionView'
const decompressionFunction = 'decompressAssertionDto'
const viewProps = JSON.parse("{\"s\":\"x y ph ) ( setvar = /\\\\ |- wff ] [ E. <-> / ->\",\"t\":\"Axiom\",\"n\":\"df-sb\",\"d\":\"Define proper substitution.  Remark 9.1 in [Megill] p. 447 (p. 15 of the\\n     preprint).  For our notation, we use ` [ y / x ] ph ` to mean \\\"the wff\\n     that results from the proper substitution of ` y ` for ` x ` in the wff\\n     ` ph ` .\\\"  That is, ` y ` properly replaces ` x ` .  For example,\\n     ` [ x / y ] z e. y ` is the same as ` z e. x ` , as shown in ~ elsb4 .  We\\n     can also use ` [ y / x ] ph ` in place of the \\\"free for\\\" side condition\\n     used in traditional predicate calculus; see, for example, ~ stdpc4 .\\n\\n     Our notation was introduced in Haskell B. Curry's _Foundations of\\n     Mathematical Logic_ (1977), p. 316 and is frequently used in textbooks of\\n     lambda calculus and combinatory logic.  This notation improves the common\\n     but ambiguous notation, \\\" ` ph ( y ) ` is the wff that results when ` y `\\n     is properly substituted for ` x ` in ` ph ( x ) ` .\\\"  For example, if the\\n     original ` ph ( x ) ` is ` x = y ` , then ` ph ( y ) ` is ` y = y ` , from\\n     which we obtain that ` ph ( x ) ` is ` x = x ` .  So what exactly does\\n     ` ph ( x ) ` mean?  Curry's notation solves this problem.\\n\\n     In most books, proper substitution has a somewhat complicated recursive\\n     definition with multiple cases based on the occurrences of free and bound\\n     variables in the wff.  Instead, we use a single formula that is exactly\\n     equivalent and gives us a direct definition.  We later prove that our\\n     definition has the properties we expect of proper substitution (see\\n     theorems ~ sbequ , ~ sbcom2 and ~ sbid2v ).\\n\\n     Note that our definition is valid even when ` x ` and ` y ` are replaced\\n     with the same variable, as ~ sbid shows.  We achieve this by having ` x `\\n     free in the first conjunct and bound in the second.  We can also achieve\\n     this by using a dummy variable, as the alternate definition ~ dfsb7 shows\\n     (which some logicians may prefer because it doesn't mix free and bound\\n     variables).  Another version that mixes free and bound variables is\\n     ~ dfsb3 .  When ` x ` and ` y ` are distinct, we can express proper\\n     substitution with the simpler expressions of ~ sb5 and ~ sb6 .\\n\\n     There are no restrictions on any of the variables, including what\\n     variables may occur in wff ` ph ` .  (Contributed by NM, 10-May-1993.)\",\"v\":\"#($(%,\",\"pa\":\"\",\"r\":\"+'.$1#-%0''#)$2%&*/#'#)$*%&&&\"}")
</script>
<script src="../v8/js/utils/all-imports.js"></script>
</body>
</html>
