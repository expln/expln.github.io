<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div id="react-container"></div>
<script>
const version = 'v8'
const relPathToRoot = '..'
const viewComponent = 'MetamathAssertionView'
const decompressionFunction = 'decompressAssertionDto'
const viewProps = JSON.parse("{\"s\":\"ph |- wff conventions.1 E\",\"t\":\"Theorem\",\"n\":\"conventions\",\"d\":\"<HTML>\\n       <p>\\n       Here are some of the conventions we use in the\\n       Metamath Proof Explorer (aka \\\"set.mm\\\"), and how they correspond to\\n       typical textbook language (skipping the many cases\\n       where they are identical).\\n       For conventions related to labels, see ~ conventions-label .\\n       </p>\\n\\n       <ul>\\n       <li><b>Notation.</b>\\n       Where possible, the notation attempts to conform to modern\\n       conventions, with variations due to our choice of the axiom system\\n       or to make proofs shorter.  However, our notation is strictly\\n       sequential (left-to-right). For example, summation is written in the\\n       form ` sum_ k e. A B ` ( ~ df-sum ) which denotes that index\\n       variable ` k ` ranges over ` A ` when evaluating ` B ` .  Thus,\\n       ` sum_ k e. NN ` ` ( 1 / ( 2 ^ k ) ) = 1 ` means 1/2 + 1/4 + 1/8 + ...\\n       = 1 ( ~ geoihalfsum ).\\n       The notation is usually explained in more detail when first introduced.\\n       </li>\\n\\n       <li><b>Axiomatic assertions ($a).</b>\\n       All axiomatic assertions ($a statements)\\n       starting with \\\" ` |- ` \\\" have labels starting\\n       with \\\"ax-\\\" (axioms) or \\\"df-\\\" (definitions).  A statement with a\\n       label starting with \\\"ax-\\\" corresponds to what is traditionally\\n       called an axiom.  A statement with a label starting with \\\"df-\\\"\\n       introduces new symbols or a new relationship among symbols\\n       that can be eliminated; they always extend the definition of\\n       a wff or class.  Metamath blindly treats $a statements as new\\n       given facts but does not try to justify them.  The mmj2 program\\n       will justify the definitions as sound as discussed below,\\n       except for 4 definitions ( ~ df-bi , ~ df-cleq , ~ df-clel , ~ df-clab )\\n       that require a more complex metalogical justification by hand.\\n       </li>\\n\\n       <li><b>Proven axioms.</b>\\n       In some cases we wish to treat an expression as an axiom in\\n       later theorems, even though it can be proved.  For example,\\n       we derive the postulates or axioms of complex arithmetic as\\n       theorems of ZFC set theory.  For convenience, after deriving\\n       the postulates, we reintroduce them as new axioms on\\n       top of set theory.  This lets us easily identify which axioms\\n       are needed for a particular complex number proof, without the\\n       obfuscation of the set theory used to derive them.  For more, see\\n       ~ mmcomplex.html .  When we wish\\n       to use a previously-proven assertion as an axiom, our convention\\n       is that we use the\\n       regular \\\"ax-NAME\\\" label naming convention to define the axiom,\\n       but we precede it with a proof of the same statement with the label\\n       \\\"axNAME\\\" .  An example is complex arithmetic axiom ~ ax-1cn ,\\n       proven by the preceding theorem ~ ax1cn .\\n       The metamath.exe program will warn if an axiom does not match the\\n       preceding theorem that justifies it if the names match in this way.\\n       </li>\\n\\n       <li><b>Definitions (df-...).</b>\\n       We encourage definitions to include hypertext links to proven examples.\\n       </li>\\n\\n       <li><b>Statements with hypotheses.</b> Many theorems and some axioms,\\n       such as ~ ax-mp , have hypotheses that must be satisfied in order for\\n       the conclusion to hold, in this case min and maj.  When presented in\\n       summarized form such as in the Theorem List (click on \\\"Nearby theorems\\\"\\n       on the ~ ax-mp page), the hypotheses are connected with an ampersand and\\n       separated from the conclusion with a big arrow, such as in \\\" ` |- ph `\\n       &amp; ` |- ( ph -> ps ) ` =&gt; ` |- ps ` \\\". These symbols are _not_\\n       part of the Metamath language but are just informal notation meaning\\n       \\\"and\\\" and \\\"implies\\\".\\n       </li>\\n\\n       <li><b>Discouraged use and modification.</b>\\n       If something should only be used in limited ways, it is marked with\\n       \\\"(New usage is discouraged.)\\\". This is used, for example, when something\\n       can be constructed in more than one way, and we do not want later\\n       theorems to depend on that specific construction.\\n       This marking is also used if we want later proofs to use proven axioms.\\n       For example, we want later proofs to\\n       use ~ ax-1cn (not ~ ax1cn ) and ~ ax-1ne0 (not ~ ax1ne0 ), as these\\n       are proven axioms for complex arithmetic.  Thus, both\\n       ~ ax1cn and ~ ax1ne0 are marked as \\\"(New usage is discouraged.)\\\".\\n       In some cases a proof should not normally be changed, e.g., when it\\n       demonstrates some specific technique.\\n       These are marked with \\\"(Proof modification is discouraged.)\\\".\\n       </li>\\n\\n       <li><b>New definitions infrequent.</b>\\n       Typically, we are minimalist when introducing new definitions; they are\\n       introduced only when a clear advantage becomes apparent for reducing\\n       the number of symbols, shortening proofs, etc.  We generally avoid\\n       the introduction of gratuitous definitions because each one requires\\n       associated theorems and additional elimination steps in proofs.\\n       For example, we use ` < ` and ` <_ ` for inequality expressions, and\\n       use ` ( ( sin `` ( _i x. A ) ) / _i ) ` instead of ` ( sinh `` A ) `\\n       for the hyperbolic sine.\\n       </li>\\n\\n       <li><b>Minimizing axioms and the axiom of choice.</b>\\n       We prefer proofs that depend on fewer and/or weaker axioms,\\n       even if the proofs are longer. In particular, we prefer proofs that do\\n       not use the axiom of choice ( ~ df-ac ) where such proofs can be found.\\n       The axiom of choice is widely accepted, and ZFC is the most\\n       commonly-accepted fundamental set of axioms for mathematics.\\n       However, there have been and still are some lingering controversies\\n       about the Axiom of Choice.  Therefore, where a proof\\n       does not require the axiom of choice, we prefer that proof instead.\\n       E.g., our proof of the Schroeder-Bernstein Theorem ( ~ sbth )\\n       does not use the axiom of choice.\\n       In some cases, the weaker axiom of countable choice ( ~ ax-cc )\\n       or axiom of dependent choice ( ~ ax-dc ) can be used instead.\\n       Similarly, any theorem in first order logic (FOL) that\\n       contains only set variables that are all mutually distinct,\\n       and has no wff variables, can be proved *without* using\\n       ~ ax-10 through ~ ax-13 , by invoking ~ ax10w through ~ ax13w .\\n       We encourage proving theorems *without* ~ ax-10 through ~ ax-13\\n       and moving them up to the ~ ax-4 through ~ ax-9 section.\\n       </li>\\n\\n       <li><b>Alternative (ALT) proofs.</b>\\n       If a different proof is significantly shorter or clearer but\\n       uses more or stronger axioms, we prefer to make that proof an\\n       \\\"alternative\\\" proof (marked with an ALT label suffix), even if\\n       this alternative proof was formalized first.\\n       We then make the proof that requires fewer axioms the main proof.\\n       This has the effect of reducing (over time)\\n       the number and strength of axioms used by any particular proof.\\n       There can be multiple alternatives if it makes sense to do so.\\n       Alternative (*ALT) theorems should have \\\"(Proof modification is\\n       discouraged.)  (New usage is discouraged.)\\\" in their comment and should\\n       follow the main statement, so that people reading the text in order will\\n       see the main statement first.  The alternative and main statement\\n       comments should use hyperlinks to refer to each other (so that a reader\\n       of one will become easily aware of the other).\\n       </li>\\n\\n       <li><b>Alternative (ALTV) versions.</b>\\n       If a theorem or definition is an alternative/variant of an already\\n       existing theorem resp. definition, its label should have the same name\\n       with suffix ALTV. Such alternatives should be temporary only, until it\\n       is decided which alternative should be used in the future.  Alternative\\n       (*ALTV) theorems or definitions are usually contained in mathboxes.\\n       Their comments need not to contain \\\"(Proof modification is discouraged.)\\n       (New usage is discouraged.)\\\".  Alternative statements should follow the\\n       main statement, so that people reading the text in order will see the\\n       main statement first.\\n       </li>\\n\\n       <li><b>Old (OLD) versions or proofs.</b>\\n       If a proof, definition, axiom, or theorem is going to be removed,\\n       we often stage that change by first renaming its\\n       label with an OLD suffix (to make it clear that it is going to\\n       be removed).  Old (*OLD) statements should have \\\"(Proof modification is\\n       discouraged.) (New usage is discouraged.)\\\" and \\\"Obsolete version of\\n       ~~ xxx as of dd-mmm-yyyy.\\\" (not enclosed in parentheses) in the comment.\\n       An old statement should follow the main statement, so that people\\n       reading the text in order will see the main statement first.\\n       This typically happens when a shorter proof to an existing theorem is\\n       found: the existing theorem is kept as an *OLD statement for one year.\\n       When a proof is shortened automatically (using Metamath's minimize_with\\n       command), then it is not necessary to keep the old proof, nor to add\\n       credit for the shortening.\\n       </li>\\n\\n       <li><b>Variables.</b>\\n       Propositional variables (variables for well-formed formulas or wffs) are\\n       represented with lowercase Greek letters and are normally used\\n       in this order:\\n       ` ph ` = phi, ` ps ` = psi, ` ch ` = chi, ` th ` = theta,\\n       ` ta ` = tau, ` et ` = eta, ` ze ` = zeta, and ` si ` = sigma.\\n       Individual setvar variables are represented with lowercase Latin letters\\n       and are normally used in this order:\\n       ` x ` , ` y ` , ` z ` , ` w ` , ` v ` , ` u ` , and ` t ` .\\n       Variables that represent classes are often represented by\\n       uppercase Latin letters:\\n       ` A ` , ` B ` , ` C ` , ` D ` , ` E ` , and so on.\\n       There are other symbols that also represent class variables and suggest\\n       specific purposes, e.g., ` .0. ` for poset zero (see ~ p0val ) and\\n       connective symbols such as ` .+ ` for some group addition operation.\\n       (See ~ prdsplusgval for an example of the use of ` .+ ` ).\\n       Class variables are selected in alphabetical order starting\\n       from ` A ` if there is no reason to do otherwise, but many\\n       assertions select different class variables or a different order\\n       to make their intended meaning clearer.\\n       </li>\\n\\n       <li><b>Turnstile.</b>\\n       \\\"` |- ` \\\", meaning \\\"It is provable that,\\\" is the first token\\n       of all assertions\\n       and hypotheses that aren't syntax constructions.  This is a standard\\n       convention in logic.  For us, it also prevents any ambiguity with\\n       statements that are syntax constructions, such as \\\"wff ` -. ph ` \\\".\\n       </li>\\n\\n       <li><b>Biconditional ( ` <-> ` ).</b>\\n       There are basically two ways to maximize the effectiveness of\\n       biconditionals ( ` <-> ` ):\\n       you can either have one-directional simplifications of all theorems\\n       that <i>produce</i> biconditionals, or you can have one-directional\\n       simplifications of theorems that <i>consume</i> biconditionals.\\n       Some tools (like Lean) follow the first approach, but set.mm follows\\n       the second approach. Practically, this means that in set.mm, for\\n       every theorem that uses an implication in the hypothesis, like\\n       ~ ax-mp , there is a corresponding version with a biconditional or a\\n       reversed biconditional, like ~ mpbi or ~ mpbir .  We prefer this\\n       second approach because the number of duplications in the second\\n       approach is bounded by the size of the propositional calculus section,\\n       which is much smaller than the number of possible theorems in all later\\n       sections that produce biconditionals.  So although theorems like\\n       ~ biimpi are available, in most cases there is already a theorem that\\n       combines it with your theorem of choice, like ~ mpbir2an , ~ sylbir ,\\n       or ~ 3imtr4i .\\n\\n       <li><b>Substitution.</b>\\n       \\\"` [ y / x ] ph ` \\\" should be read \\\"the wff that results from the\\n       proper substitution of ` y ` for ` x ` in wff ` ph ` .\\\" See ~ df-sb\\n       and the related ~ df-sbc and ~ df-csb .\\n       </li>\\n\\n       <li><b>Is-a-set.</b>\\n       \\\"` A e. _V ` \\\" should be read \\\"Class ` A ` is a set (i.e. exists).\\\"\\n       This is a convention based on Definition 2.9 of [Quine] p. 19.\\n       See ~ df-v and ~ isset .\\n       However, instead of using ` I e. _V ` in the antecedent of a theorem for\\n       some variable ` I ` , we now prefer to use ` I e. V ` (or another\\n       variable if ` V ` is not available) to make it more general. That way we\\n       can often avoid needing extra uses of ~ elex and ~ syl in the common\\n       case where ` I ` is already a member of something.\\n       For hypotheses ($e statement) of theorems (mostly in inference form),\\n       however, ` |- A e. _V ` is used rather than ` |- A e. V ` (e.g.\\n       ~ difexi ). This is because ` A e. _V ` is almost always satisfied using\\n       an existence theorem stating \\\"... ` e. _V `\\\", and a hard-coded ` _V ` in\\n       the $e statement saves a couple of syntax building steps that substitute\\n       ` _V ` into ` V `. Notice that this does not hold for hypotheses of\\n       theorems in deduction form: Here still ` |- ( ph -> A e. V ) ` should be\\n       used rather than ` |- ( ph -> A e. _V ) `.\\n       </li>\\n\\n       <li><b>Converse.</b>\\n       \\\"` ``' R ` \\\" should be read \\\"converse of (relation) ` R ` \\\"\\n       and is the same as the more standard notation R^{-1}\\n       (the standard notation is ambiguous). See ~ df-cnv .\\n       This can be used to define a subset, e.g., ~ df-tan notates\\n       \\\"the set of values whose cosine is a nonzero complex number\\\" as\\n       ` ( ``' cos \\\" ( CC \\\\ { 0 } ) ) ` .\\n       </li>\\n\\n       <li><b>Function application.</b>\\n       \\\"( ` F `` x ` )\\\" should be read \\\"the value\\n       of function ` F ` at ` x ` \\\" and has the same meaning as the more\\n       familiar but ambiguous notation F(x).  For example,\\n       ` ( cos `` 0 ) = 1 ` (see ~ cos0 ).  The left apostrophe notation\\n       originated with Peano and was adopted in Definition *30.01 of\\n       [WhiteheadRussell] p. 235, Definition 10.11 of [Quine] p. 68, and\\n       Definition 6.11 of [TakeutiZaring] p. 26.  See ~ df-fv .\\n       In the ASCII (input) representation there are spaces around the grave\\n       accent; there is a single accent when it is used directly,\\n       and it is doubled within comments.\\n       </li>\\n\\n       <li><b>Infix and parentheses.</b>\\n       When a function that takes two classes and produces a class\\n       is applied as part of an infix expression, the expression is always\\n       surrounded by parentheses (see ~ df-ov ).\\n       For example, the ` + ` in ` ( 2 + 2 ) ` ; see ~ 2p2e4 .\\n       Function application is itself an example of this.\\n       Similarly, predicate expressions\\n       in infix form that take two or three wffs and produce a wff\\n       are also always surrounded by parentheses, such as\\n       ` ( ph -> ps ) ` , ` ( ph \\\\/ ps ) ` , ` ( ph /\\\\ ps ) ` , and\\n       ` ( ph <-> ps ) `\\n       (see ~ wi , ~ df-or , ~ df-an , and ~ df-bi respectively).\\n       In contrast, a binary relation (which compares two _classes_ and\\n       produces a _wff_) applied in an infix expression is _not_\\n       surrounded by parentheses.\\n       This includes set membership ` A e. B ` (see ~ wel ),\\n       equality ` A = B ` (see ~ df-cleq ),\\n       subset ` A C_ B ` (see ~ df-ss ), and\\n       less-than ` A < B ` (see ~ df-lt ).  For the general definition\\n       of a binary relation in the form ` A R B ` , see ~ df-br .\\n       For example, ` 0 < 1 ` (see ~ 0lt1 ) does not use parentheses.\\n       </li>\\n\\n       <li><b>Unary minus.</b>\\n       The symbol ` -u ` is used to indicate a unary minus, e.g., ` -u 1 ` .\\n       It is specially defined because it is so commonly used.\\n       See ~ cneg .\\n       </li>\\n\\n       <li><b>Function definition.</b>\\n       Functions are typically defined by first defining the constant symbol\\n       (using $c) and declaring that its symbol is a class with the\\n       label cNAME (e.g., ~ ccos ).\\n       The function is then defined labeled df-NAME; definitions\\n       are typically given using the maps-to notation (e.g., ~ df-cos ).\\n       Typically, there are other proofs such as its\\n       closure labeled NAMEcl (e.g., ~ coscl ), its\\n       function application form labeled NAMEval (e.g., ~ cosval ),\\n       and at least one simple value (e.g., ~ cos0 ).\\n       </li>\\n\\n       <li><b>Factorial.</b>\\n       The factorial function is traditionally a postfix operation,\\n       but we treat it as a normal function applied in prefix form, e.g.,\\n       ` ( ! `` 4 ) = ; 2 4 ` ( ~ df-fac and ~ fac4 ).\\n       </li>\\n\\n       <li><b>Unambiguous symbols.</b>\\n       A given symbol has a single unambiguous meaning in general.\\n       Thus, where the literature might use the same symbol with different\\n       meanings, here we use different (variant) symbols for different\\n       meanings.  These variant symbols often have suffixes, subscripts,\\n       or underlines to distinguish them.  For example, here\\n       \\\"` 0 ` \\\" always means the value zero ( ~ df-0 ), while\\n       \\\"` 0g ` \\\" is the group identity element ( ~ df-0g ),\\n       \\\"` 0. ` \\\" is the poset zero ( ~ df-p0 ),\\n       \\\"` 0p ` \\\" is the zero polynomial ( ~ df-0p ),\\n       \\\"` 0vec ` \\\" is the zero vector in a normed complex vector space\\n       ( ~ df-0v ), and\\n       \\\"` .0. ` \\\" is a class variable for use as a connective symbol\\n       (this is used, for example, in ~ p0val ).\\n       There are other class variables used as connective symbols\\n       where traditional notation would use ambiguous symbols, including\\n       \\\"` .1. ` \\\", \\\"` .+ ` \\\", \\\"` .* ` \\\", and \\\"` .|| ` \\\".\\n       These symbols are very similar to traditional notation, but because\\n       they are different symbols they eliminate ambiguity.\\n       </li>\\n\\n       <li><b>ASCII representation of symbols.</b>\\n       We must have an ASCII representation for each symbol.\\n       We generally choose short sequences, ideally digraphs, and generally\\n       choose sequences that vaguely resemble the mathematical symbol.\\n       Here are some of the conventions we use when selecting an\\n       ASCII representation.\\n       <br>\\n       We generally do not include parentheses inside a symbol because\\n       that confuses text editors (such as emacs).\\n       Greek letters for wff variables always use the first two letters\\n       of their English names, making them easy to type and easy to remember.\\n       Symbols that almost look like letters, such as ` A. ` ,\\n       are often represented by that letter followed by a period.\\n       For example, \\\"A.\\\" is used to represent ` A. ` ,\\n       \\\"e.\\\" is used to represent ` e. ` , and\\n       \\\"E.\\\" is used to represent ` E. ` .\\n       Single letters are now always variable names, so constants that are\\n       often shown as single letters are now typically preceded with \\\"&#95;\\\"\\n       in their ASCII representation, for example,\\n       \\\"&#95;i\\\" is the ASCII representation for the imaginary unit ` _i ` .\\n       A script font constant is often the letter\\n       preceded by \\\"&#126;\\\" meaning \\\"curly\\\", such as \\\"&#126;P\\\" to represent\\n       the power class ` ~P ` .\\n       <br>\\n       Originally, all setvar and class variables used only single letters\\n       a-z and A-Z, respectively. A big change in recent years was to\\n       allow the use of certain symbols as variable names to make formulas\\n       more readable, such as a variable representing an additive group\\n       operation. The convention is to take the original constant token\\n       (in this case \\\"+\\\" which means complex number addition) and put\\n       a period in front of it to result in the ASCII representation of the\\n       variable \\\".+\\\", shown as ` .+ ` , that can\\n       be used instead of say the letter \\\"P\\\" that had to be used before.\\n       <br>\\n       Choosing tokens for more advanced concepts that have no standard\\n       symbols but are represented by words in books, is hard. A few are\\n       reasonably obvious, like \\\"Grp\\\" for group and \\\"Top\\\" for topology,\\n       but often they seem to end up being either too long or too\\n       cryptic. It would be nice if the math community came up with\\n       standardized short abbreviations for English math terminology,\\n       like they have more or less done with symbols, but that probably\\n       won't happen any time soon.\\n       <br>\\n       Another informal convention that we've somewhat followed, that is also\\n       not uncommon in the literature, is to start tokens with a\\n       capital letter for collection-like objects and lower case for\\n       function-like objects. For example, we have the collections On\\n       (ordinal numbers), Fin, Prime, Grp, and we have the functions sin,\\n       tan, log, sup. Predicates like Ord and Lim also tend to start\\n       with upper case, but in a sense they are really collection-like,\\n       e.g. Lim indirectly represents the collection of limit ordinals,\\n       but it can't be an actual class since not all limit ordinals\\n       are sets.\\n       This initial capital vs. lower case letter convention is sometimes\\n       ambiguous. In the past there's been a debate about whether\\n       domain and range are collection-like or function-like, thus whether\\n       we should use Dom, Ran or dom, ran. Both are used in the literature.\\n       In the end dom, ran won out for aesthetic reasons\\n       (Norm Megill simply just felt they looked nicer).\\n       </li>\\n\\n       <li><b>Typography conventions.</b>\\n       Class symbols for functions (e.g., ` abs ` , ` sin ` )\\n       should usually not have leading or trailing blanks in their\\n       HTML/Latex representation.\\n       This is in contrast to class symbols for operations\\n       (e.g., ` gcd ` , ` sadd ` , ` eval ` ), which usually do\\n       include leading and trailing blanks in their representation.\\n       If a class symbol is used for a function as well as an operation\\n       (according to the definition ~ df-ov , each operation value can be\\n       written as function value of an ordered pair), the convention for its\\n       primary usage should be used, e.g. ` ( iEdg `` G ) ` versus\\n       ` ( V iEdg E ) ` for the edges of a graph ` G = <. V , E >. ` .\\n       </li>\\n\\n       <li><b>Number construction independence.</b>\\n       There are many ways to model complex numbers.\\n       After deriving the complex number postulates we\\n       reintroduce them as new axioms on top of set theory.\\n       This lets us easily identify which axioms are needed\\n       for a particular complex number proof, without the obfuscation\\n       of the set theory used to derive them.\\n       This also lets us be independent of the specific construction,\\n       which we believe is valuable.\\n       See ~ mmcomplex.html for details.\\n       Thus, for example, we don't allow the use of ` (/) e/ CC ` ,\\n       as handy as that would be, because that would be\\n       construction-specific. We want proofs about ` CC ` to be independent\\n       of whether or not ` (/) e. CC ` .\\n       </li>\\n\\n       <li><b>Minimize hypotheses\\n       (except for construction independence and number theorem domains).</b>\\n       In most cases we try to minimize hypotheses, that is,\\n       we eliminate or reduce what must be true to prove something, so that\\n       the proof is more general and easier to use.\\n       There are exceptions. For example, we intentionally add hypotheses\\n       if they help make proofs independent of a particular construction\\n       (e.g., the contruction of complex numbers ` CC ` ).\\n       We also intentionally add hypotheses for many real and complex\\n       number theorems to expressly state their domains even when they\\n       aren't strictly needed.  For example, we could show that\\n       ` ( A < B -> B =/= A ) ` without any other hypotheses, but in\\n       practice we also require proving at least some domains\\n       (e.g., see ~ ltnei ). Here are the reasons as discussed in\\n       ~ https://groups.google.com/g/metamath/c/2AW7T3d2YiQ/m/iSN7g87t3ikJ :\\n       <ol>\\n       <li>Having the hypotheses immediately shows the intended domain of\\n       applicability (is it ` RR ` , ` RR* ` , ` _om ` , or something else?),\\n       without having to trace back to definitions.</li>\\n       <li>Having the hypotheses forces its use in the intended\\n       domain, which generally is desirable.</li>\\n       <li>The behavior is dependent on accidental behavior of definitions\\n       outside of their domains, so the theorems are non-portable and\\n       \\\"brittle\\\".</li>\\n       <li>Only a few theorems can have their hypotheses removed\\n       in this fashion due to happy coincidences for our particular\\n       set-theoretical definitions.  The poor user (especially a\\n       novice learning real number arithmetic) is going to be\\n       confused not knowing when hypotheses are needed and when\\n       they are not.  For someone who hasn't traced back the\\n       set-theoretical foundations of the definitions, it is\\n       seemingly random and isn't intuitive at all.</li>\\n       <li>The consensus of opinion of people on this group seemed to be\\n       against doing this.</li>\\n       </ol>\\n       </li>\\n\\n       <li><b>Natural numbers.</b>\\n       There are different definitions of \\\"natural\\\" numbers in the literature.\\n       We use ` NN ` ( ~ df-nn ) for the set of positive integers starting\\n       from 1, and ` NN0 ` ( ~ df-n0 ) for the set of nonnegative integers\\n       starting at zero.\\n       </li>\\n\\n       <li><b>Decimal numbers.</b>\\n       Numbers larger than nine are often expressed in base 10 using the\\n       decimal constructor ~ df-dec , e.g., ` ; ; ; 4 0 0 1 ` (see ~ 4001prm\\n       for a proof that 4001 is prime).\\n       </li>\\n\\n       <li><b>Theorem forms.</b>\\n       We will use the following descriptive terms to categorize theorems:\\n       <ul>\\n       <li>A theorem is in <b>\\\"closed form\\\"</b> if it has no $e hypotheses\\n       (e.g., ~ unss ).  The term \\\"tautology\\\" is also used, especially in\\n       propositional calculus.  This form was formerly called \\\"theorem form\\\"\\n       or \\\"closed theorem form\\\".</li>\\n       <li>A theorem is in <b>\\\"deduction form\\\"</b> (or is a \\\"deduction\\\") if it\\n       has one or more $e hypotheses, and the hypotheses and the conclusion are\\n       implications that share the same antecedent.  More precisely, the\\n       conclusion is an implication with a wff variable as the antecedent\\n       (usually ` ph `), and every hypothesis ($e statement) is either:\\n       <ol>\\n       <li>an implication with the same antecedent as the conclusion, or</li>\\n       <li>a definition.  A definition can be for a class variable (this is a\\n       class variable followed by ` = `, e.g. the definition of ` D ` in\\n       ~ lhop ) or a wff variable (this is a wff variable followed by\\n       ` <-> `); class variable definitions are more common.</li>\\n       </ol>\\n       In practice, a proof of a theorem in deduction form will also contain\\n       many steps that are implications where the antecedent is either that\\n       wff variable (usually ` ph `) or is a conjunction ` ( ph i^i ... ) `\\n       including that wff variable ( `ph ` ).  E.g. ~ a1d , ~ unssd .</li>\\n       <li> A theorem is in <b>\\\"inference form\\\"</b> (or is an \\\"inference\\\") if\\n       it has one or more $e hypotheses, but is not in deduction form,\\n       i.e. there is no common antecedent (e.g., ~ unssi ).</li>\\n       </ul>\\n\\n       Any theorem whose conclusion is an implication has an <b>associated\\n       inference</b>, whose hypotheses are the hypotheses of that theorem\\n       together with the antecedent of its conclusion, and whose conclusion is\\n       the consequent of that conclusion.  When both theorems are in set.mm,\\n       then the associated inference is often labeled by adding the suffix \\\"i\\\"\\n       to the label of the original theorem (for instance, ~ con3i is the\\n       inference associated with ~ con3 ).  The inference associated with a\\n       theorem is easily derivable from that theorem by a simple use of\\n       ~ ax-mp .  The other direction is the subject of the Deduction Theorem\\n       discussed below.  We may also use the term \\\"associated inference\\\" when\\n       the above process is iterated.  For instance, ~ syl is <em>an</em>\\n       inference associated with ~ imim1 because it is <em>the</em> inference\\n       associated with ~ imim1i which is itself <em>the</em> inference\\n       associated with ~ imim1 .\\n       <br>\\n\\n       \\\"Deduction form\\\" is the preferred form for theorems because this form\\n       allows us to easily use the theorem in places where (in traditional\\n       textbook formalizations) the standard Deduction Theorem (see below)\\n       would be used. We call this approach <b>\\\"deduction style\\\"</b>.\\n       In contrast, we usually avoid theorems in \\\"inference form\\\" when that\\n       would end up requiring us to use the deduction theorem.\\n       <br>\\n\\n       Deductions have a label suffix of \\\"d\\\", especially if there are other\\n       forms of the same theorem (e.g., ~ pm2.43d ).  The labels for inferences\\n       usually have the suffix \\\"i\\\" (e.g., ~ pm2.43i ).  The labels of theorems\\n       in \\\"closed form\\\" would have no special suffix (e.g., ~ pm2.43 ).  When\\n       an inference is converted to a theorem by eliminating an \\\"is a set\\\"\\n       hypothesis, we sometimes suffix the closed form with \\\"g\\\" (for \\\"more\\n       general\\\") as in ~ uniex vs. ~ uniexg .\\n       </li>\\n\\n       <li><b>Deduction theorem.</b>\\n       The Deduction Theorem is a metalogical theorem that provides an\\n       algorithm for constructing a proof of a theorem from the proof of its\\n       corresponding deduction (its associated inference).  See for instance\\n       Theorem 3 in [Margaris] p. 56.  In ordinary mathematics, no one actually\\n       carries out the algorithm, because (in its most basic form) it involves\\n       an exponential explosion of the number of proof steps as more hypotheses\\n       are eliminated.  Instead, in ordinary mathematics the Deduction Theorem\\n       is invoked simply to claim that something can be done in principle,\\n       without actually doing it.  For more details, see ~ mmdeduction.html .\\n       The Deduction Theorem is a metalogical theorem that cannot be applied\\n       directly in metamath, and the explosion of steps would be a problem\\n       anyway, so alternatives are used.  One alternative we use sometimes is\\n       the \\\"weak deduction theorem\\\" ~ dedth , which works in certain cases in\\n       set theory.  We also sometimes use ~ dedhb .  However, the primary\\n       mechanism we use today for emulating the deduction theorem is to write\\n       proofs in deduction form (aka \\\"deduction style\\\") as described earlier;\\n       the prefixed ` ph -> ` mimics the context in a deduction proof system.\\n       In practice this mechanism works very well.  This approach is described\\n       in the deduction form and natural deduction page ~ mmnatded.html ; a\\n       list of translations for common natural deduction rules is given in\\n       ~ natded .\\n       </li>\\n\\n       <li><b>Recursion.</b>\\n       We define recursive functions using various \\\"recursion constructors\\\".\\n       These allow us to define, with compact direct definitions, functions\\n       that are usually defined in textbooks with indirect self-referencing\\n       recursive definitions.  This produces compact definition and much\\n       simpler proofs, and greatly reduces the risk of creating unsound\\n       definitions.  Examples of recursion constructors include\\n       ` recs ( F ) ` in ~ df-recs , ` rec ( F , I ) ` in ~ df-rdg ,\\n       ` seqom ( F , I ) ` in ~ df-seqom , and ` seq M ( .+ , F ) ` in\\n       ~ df-seq .  These have characteristic function ` F ` and initial value\\n       ` I ` .  ( ` gsum ` in ~ df-gsum isn't really designed for arbitrary\\n       recursion, but you could do it with the right magma.)  The logically\\n       primary one is ~ df-recs , but for the \\\"average user\\\" the most useful\\n       one is probably ~ df-seq - provided that a countable sequence is\\n       sufficient for the recursion.\\n       </li>\\n\\n       <li><b>Extensible structures.</b>\\n       Mathematics includes many structures such as ring, group, poset, etc.\\n       We define an \\\"extensible structure\\\" which is then used to define group,\\n       ring, poset, etc.  This allows theorems from more general structures\\n       (groups) to be reused for more specialized structures (rings) without\\n       having to reprove them.  See ~ df-struct .\\n       </li>\\n\\n       <li><b>Undefined results and \\\"junk theorems\\\".</b>\\n       Some expressions are only expected to be meaningful in certain contexts.\\n       For example, consider Russell's definition description binder iota,\\n       where ` ( iota x ph ) ` is meant to be \\\"the ` x ` such that ` ph ` \\\"\\n       (where ` ph ` typically depends on x).\\n       What should that expression produce when there is no such ` x ` ?\\n       In set.mm we primarily use one of two approaches.\\n       One approach is to make the expression evaluate to the empty set\\n       whenever the expression is being used outside of its expected context.\\n       While not perfect, it makes it a bit more clear when something\\n       is undefined, and it has the advantage that it makes more\\n       things equal outside their domain which can remove hypotheses when\\n       you feel like exploiting these so-called junk theorems.\\n       Note that Quine does this with iota (his definition of iota\\n       evaluates to the empty set when there is no unique value of ` x ` ).\\n       Quine has no problem with that and we don't see why we should,\\n       so we define iota exactly the same way that Quine does.\\n       The main place where you see this being systematically exploited is in\\n       \\\"reverse closure\\\" theorems like ` A e. ( F `` B ) -> B e. dom F ` ,\\n       which is useful when ` F ` is a family of sets. (by this we\\n       mean it's a set set even in a type theoretic interpretation.)\\n       The second approach uses \\\"(New usage is discouraged.)\\\" to prevent\\n       unintentional uses of certain properties.\\n       For example, you could define some construct df-NAME whose\\n       usage is discouraged, and prove only the specific properties\\n       you wish to use (and add those proofs to the list of permitted uses\\n       of \\\"discouraged\\\" information). From then on, you can only use\\n       those specific properties without a warning.\\n       Other approaches often have hidden problems.\\n       For example, you could try to \\\"not define undefined terms\\\"\\n       by creating definitions like ${ $d ` y x ` $.  $d ` y ph ` $.\\n       df-iota $a ` |- ( E! x ph -> ( iota x ph ) = U. { x | ph } ) ` $. $}.\\n       This will be rejected by the definition checker, but the bigger\\n       theoretical reason to reject this axiom is that it breaks equality -\\n       the metatheorem ` ( x = y -> ` P(x) ` = ` P(y) ` ) ` fails\\n       to hold if definitions don't unfold without some assumptions.\\n       (That is, ~ iotabidv is no longer provable and must be added\\n       as an axiom.) It is important for every syntax constructor to\\n       satisfy equality theorems *unconditionally*, e.g., expressions\\n       like ` ( 1 / 0 ) = ( 1 / 0 ) ` should not be rejected.\\n       This is forced on us by the context free term\\n       language, and anything else requires a lot more infrastructure\\n       (e.g., a type checker) to support without making everything else\\n       more painful to use.\\n       Another approach would be to try to make nonsensical\\n       statements syntactically invalid, but that can create its own\\n       complexities; in some cases that would make parsing itself undecidable.\\n       In practice this does not seem to be a serious issue.\\n       No one does these things deliberately in \\\"real\\\" situations,\\n       and some knowledgeable people (such as Mario Carneiro)\\n       have never seen this happen accidentally.\\n       Norman Megill doesn't agree that these \\\"junk\\\" consequences are\\n       necessarily bad anyway, and they can significantly shorten proofs\\n       in some cases. This database would be much larger if, for example,\\n       we had to condition ~ fvex on the argument being in the domain\\n       of the function. It is impossible to derive a contradiction\\n       from sound definitions (i.e. that pass the definition check),\\n       assuming ZFC is consistent, and he doesn't see the point of all the\\n       extra busy work and huge increase in set.mm size that would result\\n       from restricting *all* definitions.\\n       So instead of implementing a complex system to counter a\\n       problem that does not appear to occur in practice, we use\\n       a significantly simpler set of approaches.\\n       </li>\\n\\n       <li><b>Organizing proofs.</b>\\n       Humans have trouble understanding long proofs.\\n       It is often preferable to break longer proofs into\\n       smaller parts (just as with traditional proofs). In Metamath\\n       this is done by creating separate proofs of the separate parts.\\n       A proof with the sole purpose of supporting a final proof is a\\n       lemma; the naming convention for a lemma is the final proof's name\\n       followed by \\\"lem\\\", and a number if there is more than one. E.g.,\\n       ~ sbthlem1 is the first lemma for ~ sbth .  Also, consider proving\\n       reusable results separately, so that others will be able to easily\\n       reuse that part of your work.\\n       </li>\\n\\n       <li><b>Limit proof size.</b>\\n       It is often preferable to break longer proofs into\\n       smaller parts, just as you would do with traditional proofs.\\n       One reason is that humans have trouble understanding long proofs.\\n       Another reason is that it's generally best to prove\\n       reusable results separately,\\n       so that others will be able to easily reuse them.\\n       Finally, the \\\"minimize\\\" routine can take much longer with\\n       very long proofs.\\n       We encourage proofs to be no more than 200 essential steps, and\\n       generally no more than 500 essential steps,\\n       though these are simply guidelines and not hard-and-fast rules.\\n       Much smaller proofs are fine!\\n       We also acknowledge that some proofs, especially autogenerated ones,\\n       should sometimes not be broken up (e.g., because\\n       breaking them up might be useless and inefficient due to many\\n       interconnections and reused terms within the proof).\\n       In Metamath, breaking up longer proofs is done by creating multiple\\n       separate proofs of separate parts.\\n       A proof with the sole purpose of supporting a final proof is a\\n       lemma; the naming convention for a lemma is the final proof's name\\n       followed by \\\"lem\\\", and a number if there is more than one. E.g.,\\n       ~ sbthlem1 is the first lemma for ~ sbth .\\n       </li>\\n\\n       <li><b>Hypertext links.</b>\\n       We strongly encourage comments to have many links to related material,\\n       with accompanying text that explains the relationship.  These can help\\n       readers understand the context.  Links to other statements, or to\\n       HTTP/HTTPS URLs, can be inserted in ASCII source text by prepending a\\n       space-separated tilde (e.g., \\\" ~~ df-prm \\\" results in \\\" ~ df-prm \\\").\\n       When metamath.exe is used to generate HTML it automatically inserts\\n       hypertext links for syntax used (e.g., every symbol used), every axiom\\n       and definition depended on, the justification for each step in a proof,\\n       and to both the next and previous assertion.\\n       </li>\\n\\n       <li><b>Hypertext links to section headers.</b>\\n       Some section headers have text under them that describes or explains the\\n       section.  However, they are not part of the description of axioms or\\n       theorems, and there is no way to link to them directly.  To provide for\\n       this, section headers with accompanying text (indicated with \\\"*\\\"\\n       prefixed to ~ mmtheorems.html#mmdtoc entries) have an anchor in\\n       ~ mmtheorems.html whose name is the first $a or $p statement that\\n       follows the header.  For example there is a glossary under the section\\n       heading called GRAPH THEORY.  The first $a or $p statement that follows\\n       is ~ cuhg , which you can see two lines down.  To reference it we link\\n       to the anchor using a space-separated tilde followed by the\\n       space-separated link mmtheorems.html#cuhg, which will become the\\n       hyperlink ~ mmtheorems.html#cuhg .  Note that no theorem in set.mm is\\n       allowed to begin with \\\"mm\\\" (enforced by \\\"verify markup\\\" in the metamath\\n       program).\\n       Whenever the software sees a tilde reference beginning with \\\"http:\\\",\\n       \\\"https:\\\", or \\\"mm\\\", the reference is assumed to be a link to something\\n       other than a statement label, and the tilde reference is used as is.\\n       This can also be useful for relative links to other pages such as\\n       ~ mmcomplex.html .\\n       </li>\\n\\n       <li><b>Bibliography references.</b>\\n       Please include a bibliographic reference to any external material used.\\n       A name in square brackets in a comment indicates a\\n       bibliographic reference. The full reference must be of the form\\n       KEYWORD IDENTIFIER? NOISEWORD(S)* &#91;AUTHOR(S)&#93; p. NUMBER -\\n       note that this is a very specific form that requires a page number.\\n       There should be no comma between the author reference and the\\n       \\\"p.\\\" (a constant indicator).\\n       Whitespace, comma, period, or semicolon should follow NUMBER.\\n       An example is Theorem 3.1 of [Monk1] p. 22,\\n       The KEYWORD, which is not case-sensitive,\\n       must be one of the following: Axiom, Chapter, Compare, Condition,\\n       Corollary, Definition, Equation, Example, Exercise, Figure, Item,\\n       Lemma, Lemmas, Line, Lines, Notation, Part, Postulate, Problem,\\n       Property, Proposition, Remark, Rule, Scheme, Section, or Theorem.\\n       The IDENTIFIER is optional, as in for example\\n       \\\"Remark in [Monk1] p. 22\\\".\\n       The NOISEWORDS(S) are zero or more from the list: from, in, of, on.\\n       The AUTHOR(S) must be present in the file identified with the\\n       htmlbibliography assignment (e.g., mmset.html) as a named anchor\\n       (NAME=).  If there is more than one document by the same author(s),\\n       add a numeric suffix (as shown here).\\n       The NUMBER is a page number, and may be any alphanumeric string such as\\n       an integer or Roman numeral.\\n       Note that we _require_ page numbers in comments for individual\\n       $a or $p statements.  We allow names in square brackets without\\n       page numbers (a reference to an entire document) in\\n       heading comments.\\n       If this is a new reference, please also add it to the\\n       \\\"Bibliography\\\" section of mmset.html.\\n       (The file mmbiblio.html is automatically rebuilt, e.g.,\\n       using the metamath.exe \\\"write bibliography\\\" command.)\\n       </li>\\n\\n       <li><b>Acceptable shorter proofs</b>\\n       Shorter proofs are welcome, and any shorter proof we accept\\n       will be acknowledged in the theorem's description.  However,\\n       in some cases a proof may be \\\"shorter\\\" or not depending on\\n       how it is formatted.  This section provides general guidelines.\\n\\n       <p>\\n       Usually we automatically accept shorter proofs that (1)\\n       shorten the set.mm file (with compressed proofs), (2) reduce\\n       the size of the HTML file generated with SHOW STATEMENT xx\\n       / HTML, (3) use only existing, unmodified theorems in the\\n       database (the order of theorems may be changed, though), and\\n       (4) use no additional axioms.\\n       Usually we will also automatically accept a _new_ theorem\\n       that is used to shorten multiple proofs, if the total size\\n       of set.mm (including the comment of the new theorem, not\\n       including the acknowledgment) decreases as a result.\\n       </p>\\n\\n       <p>\\n       In borderline cases, we typically place more importance on\\n       the number of compressed proof steps and less on the length\\n       of the label section (since the names are in principle\\n       arbitrary).  If two proofs have the same number of compressed\\n       proof steps, we will typically give preference to the one\\n       with the smaller number of different labels, or if these\\n       numbers are the same, the proof with the fewest number of\\n       characters that the proofs happen to have by chance when\\n       label lengths are included.\\n       </p>\\n\\n       <p>\\n       A few theorems have a longer proof than necessary in order\\n       to avoid the use of certain axioms, for pedagogical purposes,\\n       and for other reasons.  These theorems will (or should) have\\n       a \\\"(Proof modification is discouraged.)\\\" tag in their\\n       description.  For example, ~ idALT shows a proof directly from\\n       axioms.  Shorter proofs for such cases won't be accepted,\\n       of course, unless the criteria described continues to be\\n       satisfied.\\n       </p>\\n\\n       <li><b>Input format.</b>\\n       The input is in ASCII with two-space indents.  Tab characters are not\\n       allowed.  Use embedded math comments or HTML entities for non-ASCII\\n       characters (e.g., \\\"&amp;eacute;\\\" for \\\"&eacute;\\\").\\n       </li>\\n\\n       <li><b>Information on syntax, axioms, and definitions.</b>\\n       For a hyperlinked list of syntax, axioms, and definitions, see\\n       ~ mmdefinitions.html .\\n       If you have questions about a specific symbol or axiom, it is best\\n       to go directly to its definition to learn more about it.\\n       The generated HTML for each theorem and axiom includes hypertext\\n       links to each symbol's definition.\\n       </li>\\n\\n       <li><b>Reserved symbols: 'LETTER.</b>\\n       Some symbols are reserved for potential future use.\\n       Symbols with the pattern 'LETTER are reserved for possibly\\n       representing characters (this is somewhat similar to Lisp).\\n       We would expect '\\\\n to represent newline, 'sp for space, and perhaps\\n       '\\\\x24 for the dollar character.\\n       </li>\\n\\n       <li><b>Language and spelling.</b>\\n       It is preferred to use American English for comments and symbols, e.g.\\n       we use \\\"neighborhood\\\" instead of the British English \\\"neighbourhood\\\".\\n       An exception is the word \\\"analog\\\", which can be either a noun or an\\n       adjective. Furthermore, \\\"analog\\\" has the confounding meaning \\\"not\\n       digital\\\", whereas \\\"analogue\\\" is often used in the sense something that\\n       bears analogy to something else also in American English.  Therefore,\\n       \\\"analogue\\\" is used for the noun and \\\"analogous\\\" for the adjective in\\n       set.mm.\\n       </li>\\n       </ul>\\n\\n       <br><br>\\n\\n       <b>The challenge of varying mathematical conventions</b>\\n\\n       <br><br>\\n\\n       We try to follow mathematical conventions, but in many cases\\n       different texts use different conventions.\\n       In those cases we pick some reasonably common convention and stick to\\n       it.\\n       We have already mentioned that the term \\\"natural number\\\" has\\n       varying definitions (some start from 0, others start from 1), but\\n       that is not the only such case.\\n\\n       A useful example is the set of metavariables used to represent\\n       arbitrary well-formed formulas (wffs).\\n       We use an open phi, &#x3c6;, to represent the first arbitrary wff in an\\n       assertion with one or more wffs; this is a common convention and\\n       this symbol is easily distinguished from the empty set symbol.\\n       That said, it is impossible to please everyone or simply \\\"follow\\n       the literature\\\" because there are many different conventions for\\n       a variable that represents any arbitrary wff.\\n       To demonstrate the point,\\n       here are some conventions for variables that represent an arbitrary\\n       wff and some texts that use each convention:\\n\\n       <ul>\\n       <li>open phi &#x3c6; (and so on): Tarski's papers,\\n       Rasiowa &amp; Sikorski's\\n       <i>The Mathematics of Metamathematics</i> (1963),\\n       Monk's <i>Introduction to Set Theory</i> (1969),\\n       Enderton's <i>Elements of Set Theory</i> (1977),\\n       Bell &amp; Machover's <i>A Course in Mathematical Logic</i> (1977),\\n       Jech's <i>Set Theory</i> (1978),\\n       Takeuti &amp; Zaring's\\n       <i>Introduction to Axiomatic Set Theory</i> (1982).\\n       <li>closed phi &#x3d5; (and so on):\\n       Levy's <i>Basic Set Theory</i> (1979),\\n       Kunen's <i>Set Theory</i> (1980),\\n       Paulson's <i>Isabelle: A Generic Theorem Prover</i> (1994),\\n       Huth and Ryan's <i>Logic in Computer Science</i> (2004/2006).\\n       <li>Greek &alpha;, &beta;, &gamma;:\\n       Duffy's <i>Principles of Automated Theorem Proving</i> (1991).\\n       <li>Roman A, B, C:\\n       Kleene's <i>Introduction to Metamathematics</i> (1974),\\n       Smullyan's <i>First-Order Logic</i> (1968/1995).\\n       <li>script A, B, C:\\n       Hamilton's <i>Logic for Mathematicians</i> (1988).\\n       <li>italic A, B, C:\\n       Mendelson's <i>Introduction to Mathematical Logic</i> (1997).\\n       <li>italic P, Q, R:\\n       Suppes's <i>Axiomatic Set Theory</i> (1972),\\n       Gries and Schneider's <i>A Logical Approach to Discrete Math</i>\\n       (1993/1994),\\n       Rosser's <i>Logic for Mathematicians</i> (2008).\\n       <li>italic p, q, r:\\n       Quine's <i>Set Theory and Its Logic</i> (1969),\\n       Kuratowski &amp; Mostowski's <i>Set Theory</i> (1976).\\n       <li>italic X, Y, Z:\\n       Dijkstra and Scholten's\\n       <i>Predicate Calculus and Program Semantics</i> (1990).\\n       <li>Fraktur letters:\\n       Fraenkel et. al's <i>Foundations of Set Theory</i> (1973).\\n       </ul>\\n\\n       <br><br>\\n\\n       <b>Distinctness or freeness</b>\\n\\n       <br><br>\\n\\n       Here are some conventions that address distinctness or freeness of a\\n       variable:\\n\\n       <ul>\\n       <li> ` F/ x ph ` is read \\\" ` x ` is not free in (wff) ` ph ` \\\";\\n       see ~ df-nf (whose description has some important technical\\n       details).  Similarly, ` F/_ x A ` is read ` x ` is not free in (class)\\n       ` A ` , see ~ df-nfc .</li>\\n\\n       <li>\\\"$d x y $.\\\" should be read \\\"Assume x and y are distinct\\n       variables.\\\"</li>\\n\\n       <li>\\\"$d x ` ph ` $.\\\" should be read \\\"Assume x does not occur in phi $.\\\"\\n       Sometimes a theorem is proved using\\n       ` F/ x ph `  ( ~ df-nf ) in place of\\n       \\\"$d ` x ph ` $.\\\" when a more general result is desired;\\n       ~ ax-5 can be used to derive the $d version.  For an example of\\n       how to get from the $d version back to the $e version, see the\\n       proof of ~ euf from ~ df-eu .</li>\\n\\n       <li>\\\"$d x A $.\\\" should be read \\\"Assume x is not a variable occurring in\\n       class A.\\\"</li>\\n\\n       <li>\\\"$d x A $.  $d x ps $.  $e |- ` ( x = A -> ( ph <-> ps ) ) ` $.\\\"\\n       is an idiom\\n       often used instead of explicit substitution, meaning \\\"Assume psi results\\n       from the proper substitution of A for x in phi.\\\"</li>\\n\\n       <li>\\\" ` |- ( -. A. x x = y -> ... ` \\\" occurs early in some cases, and\\n       should be read \\\"If x and y are distinct\\n       variables, then...\\\"  This antecedent provides us with a technical\\n       device (called a \\\"distinctor\\\" in Section 7 of [Megill] p. 444)\\n       to avoid the need for the\\n       $d statement early in our development of predicate calculus, permitting\\n       unrestricted substitutions as conceptually simple as those in\\n       propositional calculus.  However, the $d eventually becomes a\\n       requirement, and after that this device is rarely used.</li>\\n       </ul>\\n\\n       <p>\\n       There is a general technique to replace a <tt>$d x A</tt> or\\n       <tt>$d x ph</tt> condition in a theorem with the corresponding\\n       ` F/_ x A ` or ` F/ x ph ` ; here it is.\\n       ` |- ` T[x, A] where ` $d x A `,\\n       and you wish to prove ` |- F/_ x A => |- ` T[x, A].\\n       You apply the theorem substituting ` y ` for ` x ` and ` A ` for ` A ` ,\\n       where ` y ` is a new dummy variable, so that\\n       <tt>$d y A</tt> is satisfied.\\n       You obtain ` |- ` T[y, A], and apply chvar to obtain ` |- `\\n       T[x, A] (or just use ~ mpbir if T[x, A] binds ` x `).\\n       The side goal is ` |- ( x = y -> ( ` T[y, A] ` <-> ` T[x, A] ` ) ) ` ,\\n       where you can use equality theorems, except\\n       that when you get to a bound variable you use a non-dv bound variable\\n       renamer theorem like ~ cbval . The section\\n       ~ mmtheorems32.html#mm3146s also describes the\\n       metatheorem that underlies this.\\n       </p>\\n\\n       <p>\\n       Standard Metamath verifiers do not distinguish between axioms and\\n       definitions (both are $a statements).\\n       In practice, we require that definitions (1) be conservative\\n       (a definition should not allow an expression\\n       that previously qualified as a wff but was not provable\\n       to become provable) and be eliminable\\n       (there should exist an algorithmic method for converting any\\n       expression using the definition into\\n       a logically equivalent expression that previously qualified as a wff).\\n       To ensure this, we have additional rules on almost all definitions\\n       ($a statements with a label that does not begin with ax-).\\n       These additional rules are not applied in a few cases where they\\n       are too strict ( ~ df-bi , ~ df-clab , ~ df-cleq , and ~ df-clel );\\n       see those definitions for more information.\\n       These additional rules for definitions are checked by at least\\n       mmj2's definition check (see\\n       <A HREF=\\\"https://github.com/digama0/mmj2/blob/master/\\\"\\n       >mmj2 master</a> file mmj2jar/macros/definitionCheck.js).\\n       This definition check relies on the database being very much like\\n       set.mm, down to the names of certain constants and types, so it\\n       cannot apply to all Metamath databases... but it is useful in set.mm.\\n       In this definition check, a $a-statement with a given label and\\n       typecode ` |- ` passes the test if and only if it\\n       respects the following rules (these rules require that we have\\n       an unambiguous tree parse, which is checked separately):\\n       </p>\\n\\n       <ol>\\n       <li>The expression must be a biconditional or an equality (i.e. its\\n       root-symbol must be ` <-> ` or ` = `).\\n       If the proposed definition passes this first rule, we then\\n       define its definiendum as its left hand side (LHS) and\\n       its definiens as its right hand side (RHS).\\n       We define the *defined symbol* as the root-symbol of the LHS.\\n       We define a *dummy variable* as a variable occurring\\n       in the RHS but not in the LHS.\\n       Note that the \\\"root-symbol\\\" is the root of the considered tree;\\n       it need not correspond to a single token in the database\\n       (e.g., see ~ w3o or ~ wsb ).\\n       </li>\\n       <li>The defined expression must not appear in any statement\\n       between its syntax axiom ( ` $a wff ` ) and its definition,\\n       and the defined expression must not be used in its definiens.\\n       See ~ df-3an for an example where the same symbol is used in\\n       different ways (this is allowed).\\n       </li>\\n       <li>No two variables occurring in the LHS may share a\\n       disjoint variable (DV) condition.\\n       </li>\\n       <li>All dummy variables are required to be disjoint from any\\n       other (dummy or not) variable occurring in this labeled expression.\\n       </li>\\n       <li>Either\\n       (a) there must be no non-setvar dummy variables, or\\n       (b) there must be a justification theorem.\\n       The justification theorem must be of form\\n       ` |- ( ` definiens root-symbol definiens' ` ) `\\n       where definiens' is definiens but the dummy variables are all\\n       replaced with other unused dummy variables of the same type.\\n       Note that root-symbol is ` <-> ` or ` = ` , and that setvar\\n       variables are simply variables with the ` setvar ` typecode.\\n       </li>\\n       <li>One of the following must be true:\\n       (a) there must be no setvar dummy variables,\\n       (b) there must be a justification theorem as described in rule 5, or\\n       (c) if there are setvar dummy variables, every one must not be free.\\n       That is, it must be true that\\n       ` ( ph -> A. x ph ) ` for each setvar dummy variable ` x `\\n       where ` ph ` is the definiens.\\n       We use two different tests for non-freeness; one must succeed\\n       for each setvar dummy variable ` x ` .\\n       The first test requires that the setvar dummy variable ` x `\\n       be syntactically bound\\n       (this is sometimes called the \\\"fast\\\" test, and this implies\\n       that we must track binding operators).\\n       The second test requires a successful\\n       search for the directly-stated proof of ` ( ph -> A. x ph ) `\\n       Part c of this rule is how most setvar dummy variables\\n       are handled.\\n       </li>\\n       </ol>\\n\\n       <p>\\n       Rule 3 may seem unnecessary, but it is needed.\\n       Without this rule, you can define something like\\n       cbar $a wff Foo x y $.\\n       ${ $d x y $. df-foo $a |- ( Foo x y <-> x = y ) $. $}\\n       and now \\\"Foo x x\\\" is not eliminable;\\n       there is no way to prove that it means anything in particular,\\n       because the definitional theorem that is supposed to be\\n       responsible for connecting it to the original language wants\\n       nothing to do with this expression, even though it is well formed.\\n       </p>\\n       <p>\\n       A justification theorem for a definition (if used this way)\\n       must be proven before the definition that depends on it.\\n       One example of a justification theorem is ~ vjust .\\n       The definition ~ df-v ` |- _V = { x | x = x } ` is justified\\n       by the justification theorem ~ vjust\\n       ` |- { x | x = x } = { y | y = y }  ` .\\n       Another example of a justification theorem is ~ trujust ;\\n       the definition ~ df-tru ` |- ( T. <-> ( A. x x = x -> A. x x = x ) ) `\\n       is justified by ~ trujust ` |- ( ( A. x x = x -> A. x x = x ) <->\\n       ( A. y y = y -> A. y y = y ) ) ` .\\n       </p>\\n\\n       <p>\\n       Here is more information about our processes for checking and\\n       contributing to this work:\\n       </p>\\n\\n       <ul>\\n       <li><b>Multiple verifiers.</b>\\n       This entire file is verified by multiple independently-implemented\\n       verifiers when it is checked in, giving us extremely high\\n       confidence that all proofs follow from the assumptions.\\n       The checkers also check for various other problems such as\\n       overly long lines.\\n       </li>\\n\\n       <li><b>Maximum text line length is 79 characters.</b>\\n       You can fix comment line length by running the commands scripts/rewrap\\n       or <tt>metamath 'read set.mm' 'save proof */c/f'\\n       'write source set.mm/rewrap' quit</tt> .\\n       As a general rule, a math string in a comment should be surrounded\\n       by backquotes on the same line, and if it is too long it should\\n       be broken into multiple adjacent mathstrings on multiple lines.\\n       Those commands don't modify the math content of statements.\\n       In statements we try to break before the outermost important connective\\n       (not including the typecode and perhaps not the antecedent).\\n       For examples, see ~ sqrtmulii and ~ absmax .\\n       </li>\\n\\n       <li><b>Discouraged information.</b>\\n       A separate file named \\\"discouraged\\\" lists all\\n       discouraged statements and uses of them, and this file is checked.\\n       If you change the use of discouraged things, you will need to change\\n       this file.\\n       This makes it obvious when there is a change to anything discouraged\\n       (triggering further review).\\n       </li>\\n\\n       <li><b>LRParser check.</b>\\n       Metamath verifiers ensure that $p statements follow from previous\\n       $a and $p statements.\\n       However, by itself the Metamath language permits certain kinds of\\n       syntactic ambiguity that we choose to avoid in this database.\\n       Thus, we require that this database unambiguously parse\\n       using the \\\"LRParser\\\" check (implemented by at least mmj2).\\n       (For details, see <A\\n       HREF=\\\"https://github.com/digama0/mmj2/blob/master/\\\"\\n       >mmj2 master</A> file src/mmj/verify/LRParser.java).\\n       This check\\n       <A HREF=\\\"https://github.com/metamath/set.mm/pull/754\\\"\\n       >counters, for example, a devious ambiguous construct\\n       developed by saueran at oregonstate dot edu</A>\\n       posted on Mon, 11 Feb 2019 17:32:32 -0800 (PST)\\n       based on creating definitions with mismatched parentheses.\\n       <!-- Devious Construct:\\n       ${\\n       wleftp $a wff ( ( ph ) $.\\n       wbothp $a wff ( ph ) $.\\n       df-leftp $a |- ( ( ( ph ) <-> -. ph ) $.\\n       df-bothp $a |- ( ( ph ) <-> ph ) $.\\n       anything $p |- ph $=\\n       ( wbothp wn wi wleftp df-leftp biimpi df-bothp mpbir mpbi simplim\\n       ax-mp) ABZAMACZDZCZMOEZOCQAEZNDZRNAFGSHIOFJMNKLAHJ $.\\n       $}\\n       -->\\n\\n       <li><b>Proposing specific changes.</b>\\n       Please propose specific changes as pull requests (PRs) against the\\n       \\\"develop\\\" branch of set.mm, at:\\n       ~ https://github.com/metamath/set.mm/tree/develop\\n       </li>\\n\\n       <li><b>Community.</b>\\n       We encourage anyone interested in Metamath to join our mailing list:\\n       ~ https://groups.google.com/forum/#!forum/metamath .\\n       </li>\\n       </ul>\\n       </HTML>\\n\\n       (Contributed by DAW, 27-Dec-2016.)  (New usage is discouraged.)\",\"v\":\"#%\",\"pa\":\"$#\",\"r\":\"$#\",\"p\":[\"1¦¦4¦3¦¦0¦¦¦$#\"]}")
</script>
<script src="../v8/js/utils/all-imports.js"></script>
</body>
</html>
