<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div id="react-container"></div>
<script>
const version = 'v8'
const relPathToRoot = '..'
const viewComponent = 'MetamathAssertionView'
const decompressionFunction = 'decompressAssertionDto'
const viewProps = JSON.parse("{\"s\":\"x class y A setvar B wff e. cv F wcel vy vx\",\"t\":\"Theorem\",\"n\":\"wel\",\"d\":\"Extend wff definition to include atomic formulas with the epsilon\\n     (membership) predicate.  This is read \\\" ` x ` is an element of\\n     ` y ` ,\\\" \\\" ` x ` is a member of ` y ` ,\\\" \\\" ` x ` belongs to ` y ` ,\\\"\\n     or \\\" ` y ` contains ` x ` .\\\"  Note:  The phrase \\\" ` y ` includes\\n     ` x ` \\\" means \\\" ` x ` is a subset of ` y ` ;\\\" to use it also for\\n     ` x e. y ` , as some authors occasionally do, is poor form and causes\\n     confusion, according to George Boolos (1992 lecture at MIT).\\n\\n     This syntactic construction introduces a binary non-logical predicate\\n     symbol ` e. ` (epsilon) into our predicate calculus.  We will eventually\\n     use it for the membership predicate of set theory, but that is irrelevant\\n     at this point: the predicate calculus axioms for ` e. ` apply to any\\n     arbitrary binary predicate symbol.  \\\"Non-logical\\\" means that the predicate\\n     is presumed to have additional properties beyond the realm of predicate\\n     calculus, although these additional properties are not specified by\\n     predicate calculus itself but rather by the axioms of a theory (in our\\n     case set theory) added to predicate calculus.  \\\"Binary\\\" means that the\\n     predicate has two arguments.\\n\\n     (Instead of introducing ~ wel as an axiomatic statement, as was done in an\\n     older version of this database, we introduce it by \\\"proving\\\" a special\\n     case of set theory's more general ~ wcel .  This lets us avoid overloading\\n     the ` e. ` connective, thus preventing ambiguity that would complicate\\n     certain Metamath parsers.  However, logically ~ wel is considered to be a\\n     primitive syntax, even though here it is artificially \\\"derived\\\" from\\n     ~ wcel .  Note:  To see the proof steps of this syntax proof, type \\\"show\\n     proof wel /all\\\" in the Metamath program.)  (Contributed by NM,\\n     24-Jan-2006.)\",\"v\":\"#'%'&$($\",\"pa\":\"\",\"r\":\")#*%\",\"p\":[\"1¦¦9¦12¦¦0¦¦¦'#\",\"2¦$¦3¦8¦'#¦1¦$#¦# #¦$#\",\"3¦¦9¦11¦¦0¦¦¦'%\",\"4¦&¦3¦8¦'#¦1¦$#¦# %¦$%\",\"5¦%'¦3¦10¦$& $(¦2¦)&*(¦& # ( %¦)#*%\"]}")
</script>
<script src="../v8/js/utils/all-imports.js"></script>
</body>
</html>
