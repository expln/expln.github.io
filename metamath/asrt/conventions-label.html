<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div id="react-container"></div>
<script>
const version = 'v8'
const relPathToRoot = '..'
const viewComponent = 'MetamathAssertionView'
const decompressionFunction = 'decompressAssertionDto'
const viewProps = JSON.parse("{\"s\":\"ph |- wff conventions-label.1 E\",\"t\":\"Theorem\",\"n\":\"conventions-label\",\"d\":\"<HTML>\\n       <p>\\n       The following explains some of the label conventions in use\\n       in the Metamath Proof Explorer (\\\"set.mm\\\").\\n       For the general conventions, see ~ conventions .\\n       </p>\\n\\n       <p>\\n       Every statement has a unique identifying label, which serves the\\n       same purpose as an equation number in a book.\\n       We use various label naming conventions to provide\\n       easy-to-remember hints about their contents.\\n       Labels are not a 1-to-1 mapping, because that would create\\n       long names that would be difficult to remember and tedious to type.\\n       Instead, label names are relatively short while\\n       suggesting their purpose.\\n       Names are occasionally changed to make them more consistent or\\n       as we find better ways to name them.\\n       Here are a few of the label naming conventions:\\n       </p>\\n\\n       <ul>\\n       <li><b>Axioms, definitions, and wff syntax.</b>\\n       As noted earlier, axioms are named \\\"ax-NAME\\\",\\n       proofs of proven axioms are named \\\"axNAME\\\", and\\n       definitions are named \\\"df-NAME\\\".\\n       Wff syntax declarations have labels beginning with \\\"w\\\"\\n       followed by short fragment suggesting its purpose.\\n       </li>\\n\\n       <li><b>Hypotheses.</b>\\n       Hypotheses have the name of the final axiom or theorem, followed by\\n       \\\".\\\", followed by a unique id (these ids are usually consecutive integers\\n       starting with 1, e.g. for ~ rgen \\\"rgen.1 $e |- ( x e. A -> ph ) $.\\\"\\n       or letters corresponding to the (main) class variable used in the\\n       hypothesis, e.g. for ~ mdet0 : \\\"mdet0.d $e |- D = ( N maDet R ) $.\\\").\\n       </li>\\n\\n       <li><b>Common names.</b>\\n       If a theorem has a well-known name, that name (or a short version of it)\\n       is sometimes used directly. Examples include\\n       ~ barbara and ~ stirling .\\n       </li>\\n\\n       <li><b>Principia Mathematica.</b>\\n       Proofs of theorems from Principia Mathematica often use a special\\n       naming convention: \\\"pm\\\" followed by its identifier.\\n       For example, Theorem *2.27 of [WhiteheadRussell] p. 104 is named\\n       ~ pm2.27 .\\n       </li>\\n\\n       <li><b>19.x series of theorems.</b>\\n       Similar to the conventions for the theorems from Principia Mathematica,\\n       theorems from Section 19 of [Margaris] p. 90 often use a special naming\\n       convention: \\\"19.\\\" resp. \\\"r19.\\\" (for corresponding restricted quantifier\\n       versions) followed by its identifier.\\n       For example, Theorem 38 from Section 19 of [Margaris] p. 90 is labeled\\n       ~ 19.38 , and the restricted quantifier version of Theorem 21 from\\n       Section 19 of [Margaris] p. 90 is labeled ~ r19.21 .\\n       </li>\\n\\n       <li><b>Characters to be used for labels</b>\\n       Although the specification of Metamath allows for dots/periods \\\".\\\" in\\n       any label, it is usually used only in labels for hypotheses (see above).\\n       Exceptions are the labels of theorems from Principia Mathematica and the\\n       19.x series of theorems from Section 19 of [Margaris] p. 90 (see above)\\n       and ~ 0.999... .  Furthermore, the underscore \\\"_\\\" should not be used.\\n       </li>\\n\\n       <li><b>Syntax label fragments.</b>\\n       Most theorems are named using a concatenation of syntax label fragments\\n       (omitting variables) that represent the important part of the theorem's\\n       main conclusion.  Almost every syntactic construct has a definition\\n       labeled \\\"df-NAME\\\", and normally NAME is the syntax label fragment. For\\n       example, the class difference construct ` ( A \\\\ B ) `  is defined in\\n       ~ df-dif , and thus its syntax label fragment is \\\"dif\\\".  Similarly, the\\n       subclass relation ` A C_ B ` has syntax label fragment \\\"ss\\\"\\n       because it is defined in ~ df-ss .  Most theorem names follow from\\n       these fragments, for example, the theorem proving ` ( A \\\\ B ) C_ A `\\n       involves a class difference (\\\"dif\\\") of a subset (\\\"ss\\\"), and thus is\\n       labeled ~ difss .  There are many other syntax label fragments, e.g.,\\n       singleton construct ` { A } ` has syntax label fragment \\\"sn\\\" (because it\\n       is defined in ~ df-sn ), and the pair construct ` { A , B } ` has\\n       fragment \\\"pr\\\" ( from ~ df-pr ).  Digits are used to represent\\n       themselves.  Suffixes (e.g., with numbers) are sometimes used to\\n       distinguish multiple theorems that would otherwise produce the same\\n       label.\\n       </li>\\n\\n       <li><b>Phantom definitions.</b>\\n       In some cases there are common label fragments for something that could\\n       be in a definition, but for technical reasons is not.  The is-element-of\\n       (is member of) construct ` A e. B ` does not have a df-NAME definition;\\n       in this case its syntax label fragment is \\\"el\\\".  Thus, because the\\n       theorem beginning with ` ( A e. ( B \\\\ { C } ) ` uses is-element-of\\n       (\\\"el\\\") of a class difference (\\\"dif\\\") of a singleton (\\\"sn\\\"), it is\\n       labeled ~ eldifsn .  An \\\"n\\\" is often used for negation ( ` -. ` ), e.g.,\\n       ~ nan .\\n       </li>\\n\\n       <li><b>Exceptions.</b>\\n       Sometimes there is a definition df-NAME but the label fragment is not\\n       the NAME part.  The definition should note this exception as part of its\\n       definition.  In addition, the table below attempts to list all such\\n       cases and marks them in bold.  For example, the label fragment \\\"cn\\\"\\n       represents complex numbers ` CC ` (even though its definition is in\\n       ~ df-c ) and \\\"re\\\" represents real numbers ` RR ` ( definition ~ df-r ).\\n       The empty set ` (/) ` often uses fragment 0, even though it is defined\\n       in ~ df-nul .  The syntax construct ` ( A + B ) ` usually uses the\\n       fragment \\\"add\\\" (which is consistent with ~ df-add ), but \\\"p\\\" is used as\\n       the fragment for constant theorems.  Equality ` ( A = B ) ` often uses\\n       \\\"e\\\" as the fragment.  As a result, \\\"two plus two equals four\\\" is labeled\\n       ~ 2p2e4 .\\n       </li>\\n\\n       <li><b>Other markings.</b>\\n       In labels we sometimes use \\\"com\\\" for \\\"commutative\\\", \\\"ass\\\" for\\n       \\\"associative\\\", \\\"rot\\\" for \\\"rotation\\\", and \\\"di\\\" for \\\"distributive\\\".\\n       </li>\\n\\n       <li><b>Focus on the important part of the conclusion.</b>\\n       Typically the conclusion is the part the user is most interested in.\\n       So, a rough guideline is that a label typically provides a hint\\n       about only the conclusion; a label rarely says anything about the\\n       hypotheses or antecedents.\\n       If there are multiple theorems with the same conclusion\\n       but different hypotheses/antecedents, then the labels will need\\n       to differ; those label differences should emphasize what is different.\\n       There is no need to always fully describe the conclusion; just\\n       identify the important part. For example,\\n       ~ cos0 is the theorem that provides the value for the cosine of 0;\\n       we would need to look at the theorem itself to see what that value is.\\n       The label \\\"cos0\\\" is concise and we use it instead of \\\"cos0eq1\\\".\\n       There is no need to add the \\\"eq1\\\", because there will never be a case\\n       where we have to disambiguate between different values produced by\\n       the cosine of zero, and we generally prefer shorter labels if\\n       they are unambiguous.\\n       </li>\\n\\n       <li><b>Closures and values.</b>\\n       As noted above, if a function df-NAME is defined, there is typically a\\n       proof of its value labeled \\\"NAMEval\\\" and of its closure labeld \\\"NAMEcl\\\".\\n       E.g., for cosine ( ~ df-cos ) we have value ~ cosval and closure\\n       ~ coscl .\\n       </li>\\n\\n       <li><b>Special cases.</b>\\n       Sometimes, syntax and related markings are insufficient to distinguish\\n       different theorems.  For example, there are over a hundred different\\n       implication-only theorems.  They are grouped in a more ad-hoc way that\\n       attempts to make their distinctions clearer.  These often use\\n       abbreviations such as \\\"mp\\\" for \\\"modus ponens\\\", \\\"syl\\\" for syllogism, and\\n       \\\"id\\\" for \\\"identity\\\".  It is especially hard to give good names in the\\n       propositional calculus section because there are so few primitives.\\n       However, in most cases this is not a serious problem.  There are a few\\n       very common theorems like ~ ax-mp and ~ syl that you will have no\\n       trouble remembering, a few theorem series like syl*anc and simp* that\\n       you can use parametrically, and a few other useful glue things for\\n       destructuring 'and's and 'or's (see ~ natded for a list), and that is\\n       about all you need for most things.  As for the rest, you can just\\n       assume that if it involves at most three connectives, then it is\\n       probably already proved in set.mm, and searching for it will give you\\n       the label.\\n       </li>\\n\\n       <li><b>Suffixes.</b>\\n       Suffixes are used to indicate the form of a theorem (see above).\\n       Additionally, we sometimes suffix with \\\"v\\\" the label of a theorem\\n       eliminating a hypothesis such as ` F/ x ph ` in ~ 19.21 via the use of\\n       disjoint variable conditions combined with ~ nfv .  If two (or three)\\n       such hypotheses are eliminated, the suffix \\\"vv\\\" resp. \\\"vvv\\\" is used,\\n       e.g. ~ exlimivv .\\n       Conversely, we sometimes suffix with \\\"f\\\" the label of a theorem\\n       introducing such a hypothesis to eliminate the need for the disjoint\\n       variable condition; e.g. ~ euf derived from ~ df-eu .  The \\\"f\\\" stands\\n       for \\\"not free in\\\" which is less restrictive than \\\"does not occur in.\\\"\\n       The suffix \\\"b\\\" often means \\\"biconditional\\\" ( ` <-> ` , \\\"iff\\\" , \\\"if and\\n       only if\\\"), e.g. ~ sspwb .\\n       We sometimes suffix with \\\"s\\\" the label of an inference that manipulates\\n       an antecedent, leaving the consequent unchanged.  The \\\"s\\\" means that the\\n       inference eliminates the need for a syllogism ( ~ syl ) -type inference\\n       in a proof.  A theorem label is suffixed with \\\"ALT\\\" if it provides an\\n       alternate less-preferred proof of a theorem (e.g., the proof is\\n       clearer but uses more axioms than the preferred version).\\n       The \\\"ALT\\\" may be further suffixed with a number if there is more\\n       than one alternate theorem.\\n       Furthermore, a theorem label is suffixed with \\\"OLD\\\" if there is a new\\n       version of it and the OLD version is obsolete (and will be removed\\n       within one year).\\n\\n       Finally, it should be mentioned that suffixes can be combined, for\\n       example in ~ cbvaldva ( ~ cbval in deduction form \\\"d\\\" with a not free\\n       variable replaced by a disjoint variable condition \\\"v\\\" with a\\n       conjunction as antecedent \\\"a\\\").\\n\\n       Here is a non-exhaustive list of common suffixes:\\n       <ul>\\n       <li> a : theorem having a conjunction as antecedent</li>\\n       <li> b : theorem expressing a logical equivalence</li>\\n       <li> c : contraction (e.g., ~ sylc , ~ syl2anc ), commutes\\n       (e.g., ~ biimpac )</li>\\n       <li> d : theorem in deduction form</li>\\n       <li> f : theorem with a hypothesis such as ` F/ x ph `</li>\\n       <li> g : theorem in closed form having an \\\"is a set\\\" antecedent</li>\\n       <li> i : theorem in inference form</li>\\n       <li> l : theorem concerning something at the left</li>\\n       <li> r : theorem concerning something at the right</li>\\n       <li> r : theorem with something reversed (e.g., a biconditional)</li>\\n       <li> s : inference that manipulates an antecedent (\\\"s\\\" refers to an\\n       application of ~ syl that is eliminated)</li>\\n       <li> v : theorem with one (main) disjoint variable condition</li>\\n       <li> vv : theorem with two (main) disjoint variable conditions</li>\\n       <li> w : weak(er) form of a theorem</li>\\n       <li> ALT : alternate proof of a theorem</li>\\n       <li> ALTV : alternate version of a theorem or definition</li>\\n       <li> OLD : old/obsolete version of a theorem/definition/proof</li>\\n       </ul>\\n       </li>\\n\\n       <li><b>Reuse.</b>\\n       When creating a new theorem or axiom, try to reuse abbreviations used\\n       elsewhere.  A comment should explain the first use of an abbreviation.\\n       </li>\\n       </ul>\\n\\n       <br>\\n\\n       The following table shows some commonly used abbreviations in labels, in\\n       alphabetical order.  For each abbreviation we provide a mnenomic, the\\n       source theorem or the assumption defining it, an expression showing what\\n       it looks like, whether or not it is a \\\"syntax fragment\\\" (an abbreviation\\n       that indicates a particular kind of syntax), and hyperlinks to label\\n       examples that use the abbreviation.  The abbreviation is bolded if there\\n       is a df-NAME definition but the label fragment is not NAME.  This is\\n       <i>not</i> a complete list of abbreviations, though we do want this to\\n       eventually be a complete list of exceptions.\\n       <table border=\\\"1\\\" id=\\\"naming-abbreviation-table\\\">\\n       <tr><th>Abbreviation</th><th>Mnenomic</th><th>Source</th>\\n       <th>Expression</th><th>Syntax?</th><th>Example(s)</th></tr>\\n       <tr><td>a</td><td>and (suffix)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ biimpa , ~ rexlimiva </td></tr>\\n       <tr><td>abl</td><td>Abelian group</td><td> ~ df-abl </td>\\n       <td> ` Abel ` </td><td>Yes</td><td> ~ ablgrp , ~ zringabl </td></tr>\\n       <tr><td>abs</td><td>absorption</td><td> </td> <td> </td><td>No</td>\\n       <td> ~ ressabs </td></tr>\\n       <tr><td>abs</td><td>absolute value (of a complex number)</td>\\n       <td> ~ df-abs </td><td> ` ( abs `` A ) ` </td><td>Yes</td>\\n       <td> ~ absval , ~ absneg , ~ abs1 </td></tr>\\n       <tr><td>ad</td><td>adding</td><td> </td>\\n       <td> </td><td>No</td><td> ~ adantr , ~ ad2antlr </td></tr>\\n       <tr><td>add</td><td>add (see \\\"p\\\")</td><td> ~ df-add </td>\\n       <td> ` ( A + B ) ` </td><td>Yes</td>\\n       <td> ~ addcl , ~ addcom , ~ addass </td></tr>\\n       <tr><td>al</td><td>\\\"for all\\\"</td><td> </td>\\n       <td> ` A. x ph ` </td><td>No</td><td> ~ alim , ~ alex </td></tr>\\n       <tr><td>ALT</td><td>alternative/less preferred (suffix)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ idALT </td></tr>\\n       <tr><td>an</td><td>and</td><td> ~ df-an </td>\\n       <td> ` ( ph /\\\\ ps ) ` </td><td>Yes</td>\\n       <td> ~ anor , ~ iman , ~ imnan </td></tr>\\n       <tr><td>ant</td><td>antecedent</td><td> </td>\\n       <td> </td><td>No</td><td> ~ adantr </td></tr>\\n       <tr><td>ass</td><td>associative</td><td> </td>\\n       <td> </td><td>No</td><td> ~ biass , ~ orass , ~ mulass </td></tr>\\n       <tr><td>asym</td><td>asymmetric, antisymmetric</td><td> </td>\\n       <td> </td><td>No</td><td> ~ intasym , ~ asymref , ~ posasymb </td></tr>\\n       <tr><td>ax</td><td>axiom</td><td> </td>\\n       <td> </td><td>No</td><td> ~ ax6dgen , ~ ax1cn </td></tr>\\n       <tr><td><b>bas</b>, base </td>\\n       <td>base (set of an extensible structure)</td><td> ~ df-base </td>\\n       <td> ` ( Base `` S ) ` </td><td>Yes</td>\\n       <td> ~ baseval , ~ ressbas , ~ cnfldbas </td></tr>\\n       <tr><td><b>b</b>, bi</td><td>biconditional (\\\"iff\\\", \\\"if and only if\\\")\\n       </td><td> ~ df-bi </td><td> ` ( ph <-> ps ) ` </td><td>Yes</td>\\n       <td> ~ impbid , ~ sspwb </td></tr>\\n       <tr><td>br</td><td>binary relation</td><td> ~ df-br </td>\\n       <td> ` A R B ` </td><td>Yes</td><td> ~ brab1 , ~ brun </td></tr>\\n       <tr><td>cbv</td><td>change bound variable</td><td> </td><td> </td>\\n       <td>No</td><td> ~ cbvalivw , ~ cbvrex </td></tr>\\n       <tr><td>cl</td><td>closure</td><td> </td><td> </td><td>No</td>\\n       <td> ~ ifclda , ~ ovrcl , ~ zaddcl </td></tr>\\n       <tr><td><b>cn</b></td><td>complex numbers</td><td> ~ df-c </td>\\n       <td> ` CC ` </td><td>Yes</td><td> ~ nnsscn , ~ nncn </td></tr>\\n       <tr><td>cnfld</td><td>field of complex numbers</td><td> ~ df-cnfld </td>\\n       <td> ` CCfld ` </td><td>Yes</td><td> ~ cnfldbas , ~ cnfldinv </td></tr>\\n       <tr><td>cntz</td><td>centralizer</td><td> ~ df-cntz </td>\\n       <td> ` ( Cntz `` M ) ` </td><td>Yes</td>\\n       <td> ~ cntzfval , ~ dprdfcntz </td></tr>\\n       <tr><td>cnv</td><td>converse</td><td> ~ df-cnv </td>\\n       <td> ` ``' A ` </td><td>Yes</td><td> ~ opelcnvg , ~ f1ocnv </td></tr>\\n       <tr><td>co</td><td>composition</td><td> ~ df-co </td>\\n       <td> ` ( A o. B ) ` </td><td>Yes</td><td> ~ cnvco , ~ fmptco </td></tr>\\n       <tr><td>com</td><td>commutative</td><td> </td>\\n       <td> </td><td>No</td><td> ~ orcom , ~ bicomi , ~ eqcomi </td></tr>\\n       <tr><td>con</td><td>contradiction, contraposition</td><td> </td>\\n       <td> </td><td>No</td><td> ~ condan , ~ con2d </td></tr>\\n       <tr><td>csb</td><td>class substitution</td><td> ~ df-csb </td>\\n       <td> ` [_ A / x ]_ B ` </td><td>Yes</td>\\n       <td> ~ csbid , ~ csbie2g </td></tr>\\n       <tr><td>cyg</td><td>cyclic group</td><td> ~ df-cyg </td>\\n       <td> ` CycGrp ` </td><td>Yes</td>\\n       <td> ~ iscyg , ~ zringcyg </td></tr>\\n       <tr><td>d</td><td>deduction form (suffix)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ idd , ~ impbid </td></tr>\\n       <tr><td>df</td><td>(alternate) definition (prefix)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ dfrel2 , ~ dffn2 </td></tr>\\n       <tr><td>di, distr</td><td>distributive</td><td> </td>\\n       <td> </td><td>No</td>\\n       <td> ~ andi , ~ imdi , ~ ordi , ~ difindi , ~ ndmovdistr </td></tr>\\n       <tr><td>dif</td><td>class difference</td><td> ~ df-dif </td>\\n       <td> ` ( A \\\\ B ) ` </td><td>Yes</td>\\n       <td> ~ difss , ~ difindi </td></tr>\\n       <tr><td>div</td><td>division</td><td> ~ df-div </td>\\n       <td> ` ( A / B ) ` </td><td>Yes</td>\\n       <td> ~ divcl , ~ divval , ~ divmul </td></tr>\\n       <tr><td>dm</td><td>domain</td><td> ~ df-dm </td>\\n       <td> ` dom A ` </td><td>Yes</td><td> ~ dmmpt , ~ iswrddm0 </td></tr>\\n       <tr><td><b>e, eq, equ</b></td><td>equals</td><td> ~ df-cleq </td>\\n       <td> ` A = B ` </td><td>Yes</td>\\n       <td> ~ 2p2e4 , ~ uneqri , ~ equtr </td></tr>\\n       <tr><td>el</td><td>element of</td><td> </td>\\n       <td> ` A e. B ` </td><td>Yes</td>\\n       <td> ~ eldif , ~ eldifsn , ~ elssuni </td></tr>\\n       <tr><td>eu</td><td>\\\"there exists exactly one\\\"</td><td> ~ df-eu </td>\\n       <td> ` E! x ph ` </td><td>Yes</td><td> ~ euex , ~ euabsn </td></tr>\\n       <tr><td>ex</td><td>exists (i.e. is a set)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ brrelex , ~ 0ex </td></tr>\\n       <tr><td>ex</td><td>\\\"there exists (at least one)\\\"</td><td> ~ df-ex </td>\\n       <td> ` E. x ph ` </td><td>Yes</td><td> ~ exim , ~ alex </td></tr>\\n       <tr><td>exp</td><td>export</td><td> </td>\\n       <td> </td><td>No</td><td> ~ expt , ~ expcom </td></tr>\\n       <tr><td>f</td><td>\\\"not free in\\\" (suffix)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ equs45f , ~ sbf </td></tr>\\n       <tr><td>f</td><td>function</td><td> ~ df-f </td>\\n       <td> ` F : A --> B ` </td><td>Yes</td><td> ~ fssxp , ~ opelf </td></tr>\\n       <tr><td>fal</td><td>false</td><td> ~ df-fal </td>\\n       <td> ` F. ` </td><td>Yes</td><td> ~ bifal , ~ falantru </td></tr>\\n       <tr><td>fi</td><td>finite intersection</td><td> ~ df-fi </td>\\n       <td> ` ( fi `` B ) ` </td><td>Yes</td><td> ~ fival , ~ inelfi </td></tr>\\n       <tr><td><b>fi</b>, fin</td><td>finite</td><td> ~ df-fin </td>\\n       <td> ` Fin ` </td><td>Yes</td>\\n       <td> ~ isfi , ~ snfi , ~ onfin </td></tr>\\n       <tr><td><b>fld</b></td><td>field (Note: there is an alternative\\n       definition ` Fld ` of a field, see ~ df-fld )</td><td> ~ df-field </td>\\n       <td> ` Field ` </td><td>Yes</td><td> ~ isfld , ~ fldidom </td></tr>\\n       <tr><td>fn</td><td>function with domain</td><td> ~ df-fn </td>\\n       <td> ` A Fn B ` </td><td>Yes</td><td> ~ ffn , ~ fndm </td></tr>\\n       <tr><td>frgp</td><td>free group</td><td> ~ df-frgp </td>\\n       <td> ` ( freeGrp `` I ) ` </td><td>Yes</td>\\n       <td> ~ frgpval , ~ frgpadd </td></tr>\\n       <tr><td>fsupp</td><td>finitely supported function</td>\\n       <td> ~ df-fsupp </td><td> ` R finSupp Z ` </td><td>Yes</td>\\n       <td> ~ isfsupp , ~ fdmfisuppfi , ~ fsuppco </td></tr>\\n       <tr><td>fun</td><td>function</td><td> ~ df-fun </td>\\n       <td> ` Fun F ` </td><td>Yes</td><td> ~ funrel , ~ ffun </td></tr>\\n       <tr><td>fv</td><td>function value</td><td> ~ df-fv </td>\\n       <td> ` ( F `` A ) ` </td><td>Yes</td><td> ~ fvres , ~ swrdfv </td></tr>\\n       <tr><td>fz</td><td>finite set of sequential integers</td>\\n       <td> ~ df-fz </td>\\n       <td> ` ( M ... N ) ` </td><td>Yes</td><td> ~ fzval , ~ eluzfz </td></tr>\\n       <tr><td>fz0</td><td>finite set of sequential nonnegative integers</td>\\n       <td>  </td>\\n       <td> ` ( 0 ... N ) ` </td><td>Yes</td><td> ~ nn0fz0 , ~ fz0tp </td></tr>\\n       <tr><td>fzo</td><td>half-open integer range</td><td> ~ df-fzo </td>\\n       <td> ` ( M ..^ N ) ` </td><td>Yes</td>\\n       <td> ~ elfzo , ~ elfzofz </td></tr>\\n       <tr><td>g</td><td>more general (suffix); eliminates \\\"is a set\\\"\\n       hypothsis</td><td> </td>\\n       <td> </td><td>No</td><td> ~ uniexg </td></tr>\\n       <tr><td>gra</td><td>graph</td><td> </td>\\n       <td> </td><td>No</td><td> ~ uhgrav , ~ isumgra , ~ usgrares </td></tr>\\n       <tr><td>grp</td><td>group</td><td> ~ df-grp </td>\\n       <td> ` Grp ` </td><td>Yes</td><td> ~ isgrp , ~ tgpgrp </td></tr>\\n       <tr><td>gsum</td><td>group sum</td><td> ~ df-gsum </td>\\n       <td> ` ( G gsum F ) ` </td><td>Yes</td>\\n       <td> ~ gsumval , ~ gsumwrev </td></tr>\\n       <tr><td>hash</td><td>size (of a set)</td><td> ~ df-hash </td>\\n       <td> ` ( # `` A ) ` </td><td>Yes</td>\\n       <td> ~ hashgval , ~ hashfz1 , ~ hashcl </td></tr>\\n       <tr><td>hb</td><td>hypothesis builder (prefix)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ hbxfrbi , ~ hbald , ~ hbequid </td></tr>\\n       <tr><td>hm</td><td>(monoid, group, ring) homomorphism</td><td> </td>\\n       <td> </td><td>No</td><td> ~ ismhm , ~ isghm , ~ isrhm </td></tr>\\n       <tr><td>i</td><td>inference (suffix)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ eleq1i , ~ tcsni </td></tr>\\n       <tr><td>i</td><td>implication (suffix)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ brwdomi , ~ infeq5i  </td></tr>\\n       <tr><td>id</td><td>identity</td><td> </td>\\n       <td> </td><td>No</td><td> ~ biid </td></tr>\\n       <tr><td>idm</td><td>idempotent</td><td> </td>\\n       <td> </td><td>No</td><td> ~ anidm , ~ tpidm13 </td></tr>\\n       <tr><td>im, <b>imp</b></td><td>implication (label often omitted)</td>\\n       <td> ~ df-im </td><td> ` ( A -> B ) ` </td><td>Yes</td>\\n       <td> ~ iman , ~ imnan , ~ impbidd </td></tr>\\n       <tr><td>ima</td><td>image</td><td> ~ df-ima </td>\\n       <td> ` ( A \\\" B ) ` </td><td>Yes</td><td> ~ resima , ~ imaundi </td></tr>\\n       <tr><td>imp</td><td>import</td><td> </td>\\n       <td> </td><td>No</td><td> ~ biimpa , ~ impcom </td></tr>\\n       <tr><td>in</td><td>intersection</td><td> ~ df-in </td>\\n       <td> ` ( A i^i B ) ` </td><td>Yes</td><td> ~ elin , ~ incom </td></tr>\\n       <tr><td>inf</td><td>infimum</td><td> ~ df-inf </td>\\n       <td> ` inf ( RR+ , RR* , < ) ` </td><td>Yes</td>\\n       <td> ~ fiinfcl , ~ infiso </td></tr>\\n       <tr><td>is...</td><td>is (something a) ...?</td><td> </td>\\n       <td> </td><td>No</td><td> ~ isring </td></tr>\\n       <tr><td>j</td><td>joining, disjoining</td><td> </td>\\n       <td> </td><td>No</td><td> ~ jc , ~ jaoi  </td></tr>\\n       <tr><td>l</td><td>left</td><td> </td>\\n       <td> </td><td>No</td><td> ~ olcd , ~ simpl  </td></tr>\\n       <tr><td>map</td><td>mapping operation or set exponentiation</td>\\n       <td> ~ df-map </td><td> ` ( A ^m B ) ` </td><td>Yes</td>\\n       <td> ~ mapvalg , ~ elmapex </td></tr>\\n       <tr><td>mat</td><td>matrix</td><td> ~ df-mat </td>\\n       <td> ` ( N Mat R ) ` </td><td>Yes</td>\\n       <td> ~ matval , ~ matring </td></tr>\\n       <tr><td>mdet</td><td>determinant (of a square matrix)</td>\\n       <td> ~ df-mdet </td><td> ` ( N maDet R ) ` </td><td>Yes</td>\\n       <td> ~ mdetleib , ~ mdetrlin </td></tr>\\n       <tr><td>mgm</td><td>magma</td><td> ~ df-mgm </td>\\n       <td> ` Magma ` </td><td>Yes</td>\\n       <td> ~ mgmidmo , ~ mgmlrid , ~ ismgm </td></tr>\\n       <tr><td>mgp</td><td>multiplicative group</td><td> ~ df-mgp </td>\\n       <td> ` ( mulGrp `` R ) ` </td><td>Yes</td>\\n       <td> ~ mgpress , ~ ringmgp </td></tr>\\n       <tr><td>mnd</td><td>monoid</td><td> ~ df-mnd </td>\\n       <td> ` Mnd ` </td><td>Yes</td><td> ~ mndass , ~ mndodcong </td></tr>\\n       <tr><td>mo</td><td>\\\"there exists at most one\\\"</td><td> ~ df-mo </td>\\n       <td> ` E* x ph ` </td><td>Yes</td><td> ~ eumo , ~ moim </td></tr>\\n       <tr><td>mp</td><td>modus ponens</td><td> ~ ax-mp </td>\\n       <td> </td><td>No</td><td> ~ mpd , ~ mpi </td></tr>\\n       <tr><td>mpt</td><td>modus ponendo tollens</td><td></td>\\n       <td> </td><td>No</td><td> ~ mptnan , ~ mptxor </td></tr>\\n       <tr><td>mpt</td><td>maps-to notation for a function</td>\\n       <td> ~ df-mpt </td><td> ` ( x e. A |-> B ) ` </td><td>Yes</td>\\n       <td> ~ fconstmpt , ~ resmpt </td></tr>\\n       <tr><td>mpt2</td><td>maps-to notation for an operation</td>\\n       <td> ~ df-mpt2 </td><td> ` ( x e. A , y e. B |-> C ) ` </td><td>Yes</td>\\n       <td> ~ mpt2mpt , ~ resmpt2 </td></tr>\\n       <tr><td>mul</td><td>multiplication (see \\\"t\\\")</td><td> ~ df-mul </td>\\n       <td> ` ( A x. B ) ` </td><td>Yes</td>\\n       <td> ~ mulcl , ~ divmul , ~ mulcom , ~ mulass </td></tr>\\n       <tr><td>n, not</td><td>not</td><td> </td>\\n       <td> ` -. ph ` </td><td>Yes</td>\\n       <td> ~ nan , ~ notnotr </td></tr>\\n       <tr><td>ne</td><td>not equal</td><td>df-ne</td><td> ` A =/= B ` </td>\\n       <td>Yes</td><td> ~ exmidne , ~ neeqtrd </td></tr>\\n       <tr><td>nel</td><td>not element of</td><td>df-nel</td><td> ` A e/ B `\\n       </td>\\n       <td>Yes</td><td> ~ neli , ~ nnel </td></tr>\\n       <tr><td>ne0</td><td>not equal to zero (see n0)</td><td></td>\\n       <td> ` =/= 0 ` </td><td>No</td>\\n       <td> ~ negne0d , ~ ine0 , ~ gt0ne0 </td></tr>\\n       <tr><td>nf</td><td> \\\"not free in\\\" (prefix)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ nfnd </td></tr>\\n       <tr><td>ngp</td><td>normed group</td><td> ~ df-ngp </td>\\n       <td> ` NrmGrp ` </td><td>Yes</td><td>  ~ isngp , ~ ngptps </td></tr>\\n       <tr><td>nm</td><td>norm (on a group or ring)</td><td> ~ df-nm </td>\\n       <td> ` ( norm `` W ) ` </td><td>Yes</td>\\n       <td>  ~ nmval , ~ subgnm </td></tr>\\n       <tr><td>nn</td><td>positive integers</td><td> ~ df-nn </td>\\n       <td> ` NN ` </td><td>Yes</td><td>  ~ nnsscn , ~ nncn </td></tr>\\n       <tr><td><b>nn0</b></td><td>nonnegative integers</td><td> ~ df-n0 </td>\\n       <td> ` NN0 ` </td><td>Yes</td><td>  ~ nnnn0 , ~ nn0cn </td></tr>\\n       <tr><td>n0</td><td>not the empty set (see ne0)</td><td></td>\\n       <td> ` =/= (/) ` </td><td>No</td><td> ~ n0i , ~ vn0 , ~ ssn0 </td></tr>\\n       <tr><td>OLD</td><td>old, obsolete (to be removed soon)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ 19.43OLD </td></tr>\\n       <tr><td>op</td><td>ordered pair</td><td> ~ df-op </td>\\n       <td> ` <. A , B >. ` </td><td>Yes</td><td>  ~ dfopif , ~ opth </td></tr>\\n       <tr><td>or</td><td>or</td><td> ~ df-or </td>\\n       <td> ` ( ph \\\\/ ps ) ` </td><td>Yes</td>\\n       <td> ~ orcom , ~ anor </td></tr>\\n       <tr><td>ot</td><td>ordered triple</td><td> ~ df-ot </td>\\n       <td> ` <. A , B , C >. ` </td><td>Yes</td>\\n       <td>  ~ euotd , ~ fnotovb </td></tr>\\n       <tr><td>ov</td><td>operation value</td><td> ~ df-ov </td>\\n       <td> ` ( A F B ) ` </td><td>Yes\\n       </td><td>  ~ fnotovb , ~ fnovrn </td></tr>\\n       <tr><td><b>p</b></td><td>plus (see \\\"add\\\"), for all-constant\\n       theorems</td><td> ~ df-add </td>\\n       <td> ` ( 3 + 2 ) = 5 ` </td><td>Yes</td>\\n       <td> ~ 3p2e5 </td></tr>\\n       <tr><td>pfx</td><td>prefix</td><td> ~ df-pfx </td>\\n       <td> ` ( W prefix L ) ` </td><td>Yes</td>\\n       <td> ~ pfxlen , ~ ccatpfx </td></tr>\\n       <tr><td>pm</td><td>Principia Mathematica</td><td> </td>\\n       <td> </td><td>No</td><td> ~ pm2.27 </td></tr>\\n       <tr><td>pm</td><td>partial mapping (operation)</td><td> ~ df-pm </td>\\n       <td> ` ( A ^pm B ) ` </td><td>Yes</td><td> ~ elpmi , ~ pmsspw </td></tr>\\n       <tr><td>pr</td><td>pair</td><td> ~ df-pr </td>\\n       <td> ` { A , B } ` </td><td>Yes</td>\\n       <td> ~ elpr , ~ prcom , ~ prid1g , ~ prnz </td></tr>\\n       <tr><td>prm, <b>prime</b></td><td>prime (number)</td><td> ~ df-prm </td>\\n       <td> ` Prime ` </td><td>Yes</td><td> ~ 1nprm , ~ dvdsprime </td></tr>\\n       <tr><td>pss</td><td>proper subset</td><td> ~ df-pss </td>\\n       <td> ` A C. B ` </td><td>Yes</td><td> ~ pssss , ~ sspsstri </td></tr>\\n       <tr><td>q</td><td> rational numbers (\\\"quotients\\\")</td><td> ~ df-q </td>\\n       <td> ` QQ ` </td><td>Yes</td><td> ~ elq </td></tr>\\n       <tr><td>r</td><td>right</td><td> </td>\\n       <td> </td><td>No</td><td> ~ orcd , ~ simprl  </td></tr>\\n       <tr><td>rab</td><td>restricted class abstraction</td>\\n       <td> ~ df-rab </td><td> ` { x e. A | ph } ` </td><td>Yes</td>\\n       <td> ~ rabswap , ~ df-oprab </td></tr>\\n       <tr><td>ral</td><td>restricted universal quantification</td>\\n       <td> ~ df-ral </td><td> ` A. x e. A ph ` </td><td>Yes</td>\\n       <td> ~ ralnex , ~ ralrnmpt2 </td></tr>\\n       <tr><td>rcl</td><td>reverse closure</td><td> </td>\\n       <td> </td><td>No</td><td> ~ ndmfvrcl , ~ nnarcl </td></tr>\\n       <tr><td><b>re</b></td><td>real numbers</td><td> ~ df-r </td>\\n       <td> ` RR ` </td><td>Yes</td><td> ~ recn , ~ 0re </td></tr>\\n       <tr><td>rel</td><td>relation</td><td> ~ df-rel </td><td> ` Rel A ` </td>\\n       <td>Yes</td><td> ~ brrelex , ~ relmpt2opab </td></tr>\\n       <tr><td>res</td><td>restriction</td><td> ~ df-res </td>\\n       <td> ` ( A |`` B ) ` </td><td>Yes</td>\\n       <td> ~ opelres , ~ f1ores </td></tr>\\n       <tr><td>reu</td><td>restricted existential uniqueness</td>\\n       <td> ~ df-reu </td><td> ` E! x e. A ph ` </td><td>Yes</td>\\n       <td> ~ nfreud , ~ reurex </td></tr>\\n       <tr><td>rex</td><td>restricted existential quantification</td>\\n       <td> ~ df-rex </td><td> ` E. x e. A ph ` </td><td>Yes</td>\\n       <td> ~ rexnal , ~ rexrnmpt2 </td></tr>\\n       <tr><td>rmo</td><td>restricted \\\"at most one\\\"</td>\\n       <td> ~ df-rmo </td><td> ` E* x e. A ph ` </td><td>Yes</td>\\n       <td> ~ nfrmod , ~ nrexrmo </td></tr>\\n       <tr><td>rn</td><td>range</td><td> ~ df-rn </td><td> ` ran A ` </td>\\n       <td>Yes</td><td> ~ elrng , ~ rncnvcnv </td></tr>\\n       <tr><td>rng</td><td>(unital) ring</td><td> ~ df-ring </td>\\n       <td> ` Ring ` </td><td>Yes</td>\\n       <td> ~ ringidval , ~ isring , ~ ringgrp </td></tr>\\n       <tr><td>rot</td><td>rotation</td><td> </td>\\n       <td> </td><td>No</td><td> ~ 3anrot , ~ 3orrot </td></tr>\\n       <tr><td>s</td><td>eliminates need for syllogism (suffix)</td>\\n       <td> </td> <td> </td><td>No</td><td> ~ ancoms </td></tr>\\n       <tr><td>sb</td><td>(proper) substitution (of a set)</td>\\n       <td> ~ df-sb </td><td> ` [ y / x ] ph ` </td><td>Yes</td>\\n       <td> ~ spsbe , ~ sbimi </td></tr>\\n       <tr><td>sbc</td><td>(proper) substitution of a class</td>\\n       <td> ~ df-sbc </td><td> ` [. A / x ]. ph ` </td><td>Yes</td>\\n       <td> ~ sbc2or , ~ sbcth </td></tr>\\n       <tr><td>sca</td><td>scalar</td><td> ~ df-sca </td>\\n       <td> ` ( Scalar `` H ) ` </td><td>Yes</td>\\n       <td> ~ resssca , ~ mgpsca </td></tr>\\n       <tr><td>simp</td><td>simple, simplification</td><td> </td>\\n       <td> </td><td>No</td><td> ~ simpl , ~ simp3r3 </td></tr>\\n       <tr><td>sn</td><td>singleton</td><td> ~ df-sn </td>\\n       <td> ` { A } ` </td><td>Yes</td><td> ~ eldifsn </td></tr>\\n       <tr><td>sp</td><td>specialization</td><td> </td>\\n       <td> </td><td>No</td><td> ~ spsbe , ~ spei </td></tr>\\n       <tr><td>ss</td><td>subset</td><td> ~ df-ss </td>\\n       <td> ` A C_ B ` </td><td>Yes</td><td> ~ difss </td></tr>\\n       <tr><td>struct</td><td>structure</td><td> ~ df-struct </td>\\n       <td> ` Struct ` </td><td>Yes</td><td> ~ brstruct , ~ structfn </td></tr>\\n       <tr><td>sub</td><td>subtract</td><td> ~ df-sub </td>\\n       <td> ` ( A - B ) ` </td><td>Yes</td>\\n       <td> ~ subval , ~ subaddi </td></tr>\\n       <tr><td>sup</td><td>supremum</td><td> ~ df-sup </td>\\n       <td> ` sup ( A , B , < ) ` </td><td>Yes</td>\\n       <td> ~ fisupcl , ~ supmo </td></tr>\\n       <tr><td>supp</td><td>support (of a function)</td><td> ~ df-supp </td>\\n       <td> ` ( F supp Z ) ` </td><td>Yes</td>\\n       <td> ~ ressuppfi , ~ mptsuppd </td></tr>\\n       <tr><td>swap</td><td>swap (two parts within a theorem)</td>\\n       <td> </td><td> </td><td>No</td><td> ~ rabswap , ~ 2reuswap </td></tr>\\n       <tr><td>syl</td><td>syllogism</td><td> ~ syl </td>\\n       <td> </td><td>No</td><td> ~ 3syl </td></tr>\\n       <tr><td>sym</td><td>symmetric</td><td> </td>\\n       <td> </td><td>No</td><td> ~ df-symdif , ~ cnvsym </td></tr>\\n       <tr><td>symg</td><td>symmetric group</td><td> ~ df-symg </td>\\n       <td> ` ( SymGrp `` A ) ` </td><td>Yes</td>\\n       <td> ~ symghash , ~ pgrpsubgsymg </td></tr>\\n       <tr><td><b>t</b></td>\\n       <td>times (see \\\"mul\\\"), for all-constant theorems</td>\\n       <td> ~ df-mul </td>\\n       <td> ` ( 3 x. 2 ) = 6 ` </td><td>Yes</td>\\n       <td> ~ 3t2e6 </td></tr>\\n       <tr><td>th</td><td>theorem</td><td> </td>\\n       <td> </td><td>No</td><td> ~ nfth , ~ sbcth , ~ weth </td></tr>\\n       <tr><td>tp</td><td>triple</td><td> ~ df-tp </td>\\n       <td> ` { A , B , C } ` </td><td>Yes</td>\\n       <td> ~ eltpi , ~ tpeq1 </td></tr>\\n       <tr><td>tr</td><td>transitive</td><td> </td>\\n       <td> </td><td>No</td><td> ~ bitrd , ~ biantr </td></tr>\\n       <tr><td>tru</td><td>true</td><td> ~ df-tru </td>\\n       <td> ` T. ` </td><td>Yes</td><td> ~ bitru , ~ truanfal </td></tr>\\n       <tr><td>un</td><td>union</td><td> ~ df-un </td>\\n       <td> ` ( A u. B ) ` </td><td>Yes</td>\\n       <td> ~ uneqri , ~ uncom </td></tr>\\n       <tr><td>unit</td><td>unit (in a ring)</td>\\n       <td> ~ df-unit </td><td> ` ( Unit `` R ) ` </td><td>Yes</td>\\n       <td> ~ isunit , ~ nzrunit </td></tr>\\n       <tr><td>v</td><td>disjoint variable conditions used when\\n       a not-free hypothesis (suffix)</td>\\n       <td> </td> <td> </td><td>No</td><td> ~ spimv </td></tr>\\n       <tr><td>vv</td><td>2 disjoint variables (in a not-free hypothesis)\\n       (suffix)</td><td> </td> <td> </td><td>No</td><td> ~ 19.23vv </td></tr>\\n       <tr><td>w</td><td>weak (version of a theorem) (suffix)</td><td> </td>\\n       <td> </td><td>No</td><td> ~ ax11w , ~ spnfw </td></tr>\\n       <tr><td><b>wrd</b></td><td>word</td>\\n       <td> ~ df-word </td><td> ` Word S ` </td><td>Yes</td>\\n       <td> ~ iswrdb , ~ wrdfn , ~ ffz0iswrd </td></tr>\\n       <tr><td>xp</td><td>cross product (Cartesian product)</td>\\n       <td> ~ df-xp </td><td> ` ( A X. B ) ` </td><td>Yes</td>\\n       <td> ~ elxp , ~ opelxpi , ~ xpundi </td></tr>\\n       <tr><td>xr</td><td>eXtended reals</td><td> ~ df-xr </td>\\n       <td> ` RR* ` </td><td>Yes</td><td> ~ ressxr , ~ rexr , ~ 0xr </td></tr>\\n       <tr><td>z</td><td> integers (from German \\\"Zahlen\\\")</td>\\n       <td> ~ df-z </td><td> ` ZZ ` </td><td>Yes</td>\\n       <td> ~ elz , ~ zcn </td></tr>\\n       <tr><td>zn</td><td> ring of integers ` mod n ` </td><td> ~ df-zn </td>\\n       <td> ` ( Z/nZ `` N ) ` </td><td>Yes</td>\\n       <td> ~ znval , ~ zncrng , ~ znhash </td></tr>\\n       <tr><td>zring</td><td>ring of integers</td><td> ~ df-zring </td>\\n       <td> ` ZZring ` </td><td>Yes</td><td> ~ zringbas , ~ zringcrng\\n       </td></tr>\\n       <tr><td><b>0, z</b></td>\\n       <td>slashed zero (empty set) (see n0)</td><td> ~ df-nul </td>\\n       <td> ` (/) ` </td><td>Yes</td>\\n       <td> ~ n0i , ~ vn0 ; ~ snnz , ~ prnz </td></tr>\\n       </table>\\n\\n       </HTML>\\n\\n       (Contributed by DAW, 27-Dec-2016.)  (New usage is discouraged.)\",\"v\":\"#%\",\"pa\":\"$#\",\"r\":\"$#\",\"p\":[\"1¦¦4¦3¦¦0¦¦¦$#\"]}")
</script>
<script src="../v8/js/utils/all-imports.js"></script>
</body>
</html>
