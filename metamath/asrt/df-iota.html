<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div id="react-container"></div>
<script>
const version = 'v8'
const relPathToRoot = '..'
const viewComponent = 'MetamathAssertionView'
const decompressionFunction = 'decompressAssertionDto'
const viewProps = JSON.parse("{\"s\":\"} { y x ph | setvar = |- wff iota U. ) (\",\"t\":\"Axiom\",\"n\":\"df-iota\",\"d\":\"Define Russell's definition description binder, which can be read as\\n       \\\"the unique ` x ` such that ` ph ` ,\\\" where ` ph ` ordinarily contains\\n       ` x ` as a free variable.  Our definition is meaningful only when there\\n       is exactly one ` x ` such that ` ph ` is true (see ~ iotaval );\\n       otherwise, it evaluates to the empty set (see ~ iotanul ).  Russell used\\n       the inverted iota symbol ` iota ` to represent the binder.\\n\\n       Sometimes proofs need to expand an iota-based definition.  That is,\\n       given \\\"X = the x for which ... x ... x ...\\\" holds, the proof needs to\\n       get to \\\"...  X ...  X ...\\\".  A general strategy to do this is to use\\n       ~ riotacl2 (or ~ iotacl for unbounded iota), as demonstrated in the\\n       proof of ~ supub .  This can be easier than applying ~ riotasbc or a\\n       version that applies an explicit substitution, because substituting an\\n       iota into its own property always has a bound variable clash which must\\n       be first renamed or else guarded with NF.\\n\\n       (Contributed by Andrew Salmon, 30-Jun-2011.)\",\"v\":\"%)&)',\",\"pa\":\"\",\"r\":\"+0-&'/*.$%($&('#*$%##\"}")
</script>
<script src="../v8/js/utils/all-imports.js"></script>
</body>
</html>
