<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div id="react-container"></div>
<script>
const version = 'v8'
const relPathToRoot = '..'
const viewComponent = 'MetamathAssertionView'
const decompressionFunction = 'decompressAssertionDto'
const viewProps = JSON.parse("{\"s\":\") ( -> ps ph -. wff <-> |-\",\"t\":\"Axiom\",\"n\":\"df-bi\",\"d\":\"Define the biconditional (logical 'iff').\\n\\n     The definition ~ df-bi in this section is our first definition, which\\n     introduces and defines the biconditional connective ` <-> ` .  We define a\\n     wff of the form ` ( ph <-> ps ) ` as an abbreviation for\\n     ` -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ` .\\n\\n     Unlike most traditional developments, we have chosen not to have a\\n     separate symbol such as \\\"Df.\\\" to mean \\\"is defined as.\\\"  Instead, we will\\n     later use the biconditional connective for this purpose ( ~ df-or is its\\n     first use), as it allows us to use logic to manipulate definitions\\n     directly.  This greatly simplifies many proofs since it eliminates the\\n     need for a separate mechanism for introducing and eliminating definitions.\\n     Of course, we cannot use this mechanism to define the biconditional\\n     itself, since it hasn't been introduced yet.  Instead, we use a more\\n     general form of definition, described as follows.\\n\\n     In its most general form, a definition is simply an assertion that\\n     introduces a new symbol (or a new combination of existing symbols, as in\\n     ~ df-3an ) that is eliminable and does not strengthen the existing\\n     language.  The latter requirement means that the set of provable\\n     statements not containing the new symbol (or new combination) should\\n     remain exactly the same after the definition is introduced.  Our\\n     definition of the biconditional may look unusual compared to most\\n     definitions, but it strictly satisfies these requirements.\\n\\n     The justification for our definition is that if we mechanically replace\\n     ` ( ph <-> ps ) ` (the definiendum i.e. the thing being defined) with\\n     ` -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ` (the definiens i.e. the\\n     defining expression) in the definition, the definition becomes the\\n     previously proved theorem ~ bijust .  It is impossible to use ~ df-bi to\\n     prove any statement expressed in the original language that can't be\\n     proved from the original axioms, because if we simply replace each\\n     instance of ~ df-bi in the proof with the corresponding ~ bijust instance,\\n     we will end up with a proof from the original axioms.\\n\\n     Note that from Metamath's point of view, a definition is just another\\n     axiom - i.e. an assertion we claim to be true - but from our high level\\n     point of view, we are not strengthening the language.  To indicate this\\n     fact, we prefix definition labels with \\\"df-\\\" instead of \\\"ax-\\\".  (This\\n     prefixing is an informal convention that means nothing to the Metamath\\n     proof verifier; it is just a naming convention for human readability.)\\n\\n     After we define the constant true ` T. ` ( ~ df-tru ) and the constant\\n     false ` F. ` ( ~ df-fal ), we will be able to prove these truth table\\n     values: ` ( ( T. <-> T. ) <-> T. ) ` ( ~ trubitru ),\\n     ` ( ( T. <-> F. ) <-> F. ) ` ( ~ trubifal ), ` ( ( F. <-> T. ) <-> F. ) `\\n     ( ~ falbitru ), and ` ( ( F. <-> F. ) <-> T. ) ` ( ~ falbifal ).\\n\\n     See ~ dfbi1 , ~ dfbi2 , and ~ dfbi3 for theorems suggesting typical\\n     textbook definitions of ` <-> ` , showing that our definition has the\\n     properties we expect.  Theorem ~ dfbi1 is particularly useful if we want\\n     to eliminate ` <-> ` from an expression to convert it to primitives.\\n     Theorem ~ dfbi shows this definition rewritten in an abbreviated form\\n     after conjunction is introduced, for easier understanding.\\n\\n     Contrast with ` \\\\/ ` ( ~ df-or ), ` -> ` ( ~ wi ), ` -/\\\\ ` ( ~ df-nan ),\\n     and ` \\\\/_ ` ( ~ df-xor ) .  In some sense ` <-> ` returns true if two\\n     truth values are equal; ` = ` ( ~ df-cleq ) returns true if two classes\\n     are equal.  (Contributed by NM, 27-Dec-1992.)\",\"v\":\"&)')\",\"pa\":\"\",\"r\":\"+($$$'*&#%($$'%&#%($&%'###%($($$'%&#%($&%'##%$'*&###\"}")
</script>
<script src="../v8/js/utils/all-imports.js"></script>
</body>
</html>
